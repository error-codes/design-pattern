# 结构型模式

## 适配器模式

### 适配器模式：让不兼容的接口兼容

#### 现实场景：电源插座适配器

假设你旅行到另一个国家，发现你带的电器插头和当地的电源插座不兼容。为了让电器能够正常使用，你需要一个插座适配器，它能够将你的电器插头转换成适合当地插座的类型。这就是**适配器模式**的一个典型应用，适配器充当了不同接口之间的桥梁。

### 什么是适配器模式？

**适配器模式（Adapter Pattern）** 是一种结构型设计模式，它允许将一个类的接口转换成客户端所期望的另一个接口。适配器模式使得原本由于接口不兼容而无法一起工作的类能够协同工作。它的核心思想是：通过一个适配器，将原接口适配成目标接口，以实现不同接口之间的兼容。

### 适配器模式的核心角色

1. **目标接口（Target）：**
   - 客户端所期望的接口，也就是需要适配的接口。客户端会与目标接口交互。
2. **源接口（Adaptee）：**
   - 需要被适配的接口。该接口在系统中已有，但与目标接口不兼容。
3. **适配器（Adapter）：**
   - 适配器通过实现目标接口，并将请求委托给源接口，从而适配源接口和目标接口。适配器将源接口的方法转换为目标接口所期望的形式。

### 为什么使用适配器模式？

1. **接口不兼容**：当你需要集成的类接口不兼容时，使用适配器模式可以将其转化为目标接口，确保两者能够兼容。
2. **复用现有代码**：适配器模式通过适配器的方式，使得已有的类可以在新的环境下使用，避免了重新编写大量的代码。
3. **系统解耦**：通过引入适配器，可以将不同模块之间的耦合关系减少，使得系统更加灵活和可扩展。

### 适配器模式的实现方法

1. **目标接口**：定义客户端所期望的接口。
2. **源接口**：定义现有的不兼容接口。
3. **适配器**：实现目标接口，并将请求委托给源接口。

### 示例：电源插座适配器

假设我们有不同类型的插座，客户端需要插入两种不同类型的插头。为了让这些插头能够兼容，我们设计一个适配器类来适配插座。

#### 1. **目标接口（Target）**

```java
// 电源接口：客户端期望的接口
public interface PowerSocket {
    void plugIn();  // 客户端希望使用的方法
}
```

#### 2. **源接口（Adaptee）**

```java
// 旧插座接口：现有的接口（需要适配）
public class OldPowerSocket {
    public void insert() {
        System.out.println("插头插入到旧插座");
    }
}
```

#### 3. **适配器（Adapter）**

```java
// 适配器类，将旧插座的接口适配成目标接口
public class PowerAdapter implements PowerSocket {
    private OldPowerSocket oldPowerSocket;  // 源接口（旧插座）

    public PowerAdapter(OldPowerSocket oldPowerSocket) {
        this.oldPowerSocket = oldPowerSocket;
    }

    // 将旧插座的 insert 方法适配为目标接口的 plugIn 方法
    @Override
    public void plugIn() {
        oldPowerSocket.insert();  // 委托调用旧插座的方法
    }
}
```

#### 4. **客户端代码**

```java
public class Client {
    public static void main(String[] args) {
        // 旧插座
        OldPowerSocket oldSocket = new OldPowerSocket();

        // 创建适配器，适配旧插座
        PowerSocket adapter = new PowerAdapter(oldSocket);

        // 客户端通过目标接口使用插座
        adapter.plugIn();  // 输出：插头插入到旧插座
    }
}
```

#### 运行结果

```tex
插头插入到旧插座
```

### 优缺点分析

**优点**：

1. **提高系统的灵活性**：通过适配器模式，可以让不兼容的接口协同工作，使系统更加灵活。
2. **重用现有类**：适配器模式可以将已经存在的类通过适配器与新的接口兼容，而无需修改原有类。
3. **减少类的数量**：通过引入适配器，而不是直接修改源类，可以减少新增类的数量。

**缺点**：

1. **增加系统复杂性**：引入适配器类后，会增加类的数量，使得系统的结构变得更加复杂。
2. **性能开销**：适配器模式引入了一层适配器，这可能会带来一些性能开销，尤其在频繁调用时。

### 最佳实践

1. **只在接口不兼容时使用**：适配器模式主要用于解决接口不兼容问题，如果接口本身可以兼容，最好不要引入适配器。
2. **避免过度适配**：如果适配器层次过深，可能导致代码过于复杂，最好通过简单的接口设计避免这种情况。
3. **适配器与多态结合**：适配器模式与多态结合使用时，可以灵活处理不同的对象，使得客户端可以通过统一的接口与不同的类进行交互。

### 总结

适配器模式通过引入适配器类，将不兼容的接口转换为客户端所期望的目标接口。它能够让不同接口的类协同工作，并且有助于复用已有代码。适配器模式特别适用于当已有系统中的接口不兼容时，或者需要集成多个第三方库时。不过，适配器模式也可能带来一定的性能开销，因此需要谨慎使用。

------

## 装饰模式

### 装饰模式：动态地给对象添加职责

#### 现实场景：咖啡店的定制饮品

在咖啡店，你可以根据个人口味定制咖啡，比如选择加奶、加糖、加巧克力等。这些添加是动态的，可以根据不同需求进行装饰而不改变咖啡的基本属性。这个场景就类似于**装饰模式**，其中咖啡是核心对象，而加奶、加糖等行为是通过装饰器动态添加的。

### 什么是装饰模式？

**装饰模式（Decorator Pattern）** 是一种结构型设计模式，它允许你在不改变对象本身的情况下，动态地给对象添加额外的功能。装饰模式通过将对象嵌套到装饰器中，从而扩展了对象的功能。装饰模式通常用于替代继承，提供更加灵活的扩展方式。

### 装饰模式的核心角色

1. **组件接口（Component）：**
   - 定义了一个基本的接口，所有的具体组件和装饰器都必须实现这个接口。
2. **具体组件（Concrete Component）：**
   - 实现了组件接口，表示需要扩展功能的核心对象。
3. **装饰器（Decorator）：**
   - 实现了组件接口，并持有一个**指向组件的引用**。装饰器通过在核心对象的基础上添加额外的功能来扩展其行为。
4. **具体装饰器（Concrete Decorator）：**
   - 继承自装饰器，扩展具体的功能，它会在调用核心对象的方法时，增加一些额外的行为。

### 为什么使用装饰模式？

1. **动态扩展功能**：装饰模式允许在运行时动态地给对象添加新的行为，而不需要改变对象的结构。
2. **替代继承**：装饰模式提供了比继承更灵活的方式来扩展对象功能，可以避免多层继承带来的复杂性。
3. **单一职责原则**：装饰模式通过将功能拆分到不同的装饰器中，每个装饰器只负责一种功能，从而遵循了单一职责原则。

### 装饰模式的实现方法

1. **组件接口**：定义基本的行为接口。
2. **具体组件**：实现组件接口，提供基础功能。
3. **装饰器**：通过持有一个组件实例，并在调用其方法时增加功能。
4. **具体装饰器**：继承装饰器，提供具体的扩展功能。

### 示例：咖啡饮品定制

假设我们有一个咖啡类，客户可以根据个人口味在咖啡上添加不同的配料（如加糖、加奶等）。我们使用装饰模式来实现这种需求。

#### 1. **组件接口（Component）**

```java
// 定义饮品的接口
public interface Coffee {
    String getDescription();  // 获取饮品描述
    double cost();  // 获取饮品价格
}
```

#### 2. **具体组件（Concrete Component）**

```java
// 具体的饮品类：黑咖啡
public class Espresso implements Coffee {

    @Override
    public String getDescription() {
        return "Espresso";
    }

    @Override
    public double cost() {
        return 5.0;  // 基本咖啡价格
    }
}
```

#### 3. **装饰器（Decorator）**

```java
// 装饰器类，持有一个 Coffee 对象
public abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;

    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }

    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription();
    }

    @Override
    public double cost() {
        return decoratedCoffee.cost();
    }
}
```

#### 4. **具体装饰器（Concrete Decorator）**

```java
// 具体装饰器类：加糖
public class SugarDecorator extends CoffeeDecorator {

    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }

    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription() + ", Sugar";
    }

    @Override
    public double cost() {
        return decoratedCoffee.cost() + 0.5;  // 加糖增加的价格
    }
}

// 具体装饰器类：加奶
public class MilkDecorator extends CoffeeDecorator {

    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }

    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription() + ", Milk";
    }

    @Override
    public double cost() {
        return decoratedCoffee.cost() + 1.0;  // 加奶增加的价格
    }
}
```

#### 5. **客户端代码**

```java
public class Client {
    public static void main(String[] args) {
        // 创建一杯基本的Espresso
        Coffee coffee = new Espresso();
        System.out.println(coffee.getDescription() + " $" + coffee.cost());

        // 为Espresso加糖
        coffee = new SugarDecorator(coffee);
        System.out.println(coffee.getDescription() + " $" + coffee.cost());

        // 为咖啡加奶
        coffee = new MilkDecorator(coffee);
        System.out.println(coffee.getDescription() + " $" + coffee.cost());
    }
}
```

#### 运行结果

```
text复制代码Espresso $5.0
Espresso, Sugar $5.5
Espresso, Sugar, Milk $6.5
```

### 优缺点分析

**优点**：

1. **灵活性**：可以动态地增加或删除功能，不需要修改对象本身。
2. **符合开闭原则**：对扩展开放，对修改关闭。可以通过添加新的装饰器类来扩展功能，而无需修改现有的代码。
3. **功能分离**：每个装饰器类只负责一种特定的功能，遵循了单一职责原则。

**缺点**：

1. **类的数量增加**：如果需要许多不同的装饰功能，可能会创建大量的装饰器类。
2. **系统复杂性增加**：多个装饰器嵌套可能会导致系统变得更加复杂，尤其是装饰器层次过深时。

### 最佳实践

1. **适当使用装饰器**：当需要为对象动态添加行为时，装饰模式非常合适。但如果功能非常简单，可能不需要使用装饰模式。
2. **避免过多的装饰器**：装饰器的数量应适度，过多的装饰器可能导致代码难以维护。
3. **优先使用组合而非继承**：装饰模式通过组合来扩展对象功能，避免了继承的复杂性。

### 总结

装饰模式通过在运行时动态地给对象添加新的功能，避免了使用继承时可能带来的问题。它遵循开闭原则，并且通过组合不同的装饰器，可以非常灵活地扩展对象的行为。尽管装饰模式增加了类的数量，但在需要扩展功能时，尤其是功能种类众多时，它比继承更加灵活和可维护。

------

## 外观模式

### 外观模式：为子系统提供统一接口

#### 现实场景：智能家居的控制中心

假设你家里有各种智能设备，比如智能灯、智能电视和智能空调。每个设备都有自己的控制方式。如果每次都需要分别操作这些设备会非常麻烦。那么，假如有一个智能家居控制中心，可以一键开启或关闭所有设备，操作就会变得简单方便。这种**简化复杂系统接口**的方式就是**外观模式**的典型应用。

------

### 什么是外观模式？

**外观模式（Facade Pattern）** 是一种结构型设计模式，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。它的核心思想是通过一个外观类，将复杂的子系统接口封装起来，客户端只需通过外观类与子系统交互，而不需要了解子系统的内部实现。

------

### 外观模式的核心角色

1. **外观类（Facade）：**
   - 提供一个高层接口，供客户端访问子系统的功能。
   - 它封装了子系统的复杂性，简化了客户端与子系统的交互。
2. **子系统（Subsystem）：**
   - 包含具体的业务逻辑和实现细节。
   - 子系统的组件独立工作，不直接与外观类通信。
3. **客户端（Client）：**
   - 通过外观类与子系统交互。

------

### 为什么使用外观模式？

1. **简化复杂系统**：通过外观类，隐藏子系统的复杂性，提供一个简洁的接口，方便客户端使用。
2. **解耦客户端和子系统**：外观类充当了客户端与子系统之间的中介，从而降低了它们之间的耦合度。
3. **提升代码可维护性**：子系统的实现细节对客户端隐藏，外观类提供的统一接口使得系统更易维护。

------

### 外观模式的实现方法

1. **定义子系统类**：实现具体的功能逻辑。
2. **定义外观类**：封装对子系统类的调用，提供统一接口。
3. **客户端代码**：通过外观类与子系统交互。

------

### 示例：智能家居控制中心

假设我们有三个智能设备：灯光、电视和空调。通过外观模式，我们设计一个智能家居控制中心，可以统一管理这些设备。

------

#### 1. **子系统类（Subsystem）**

```java
// 智能灯光
public class Light {
    public void turnOn() {
        System.out.println("灯光已打开");
    }

    public void turnOff() {
        System.out.println("灯光已关闭");
    }
}

// 智能电视
public class TV {
    public void turnOn() {
        System.out.println("电视已打开");
    }

    public void turnOff() {
        System.out.println("电视已关闭");
    }
}

// 智能空调
public class AirConditioner {
    public void turnOn() {
        System.out.println("空调已打开");
    }

    public void turnOff() {
        System.out.println("空调已关闭");
    }
}
```

#### 2. **外观类（Facade）**

```java
// 外观类：智能家居控制中心
public class SmartHomeFacade {
    private Light light;
    private TV tv;
    private AirConditioner airConditioner;

    public SmartHomeFacade() {
        this.light = new Light();
        this.tv = new TV();
        this.airConditioner = new AirConditioner();
    }

    // 一键开启所有设备
    public void turnOnAll() {
        System.out.println("一键开启所有设备：");
        light.turnOn();
        tv.turnOn();
        airConditioner.turnOn();
    }

    // 一键关闭所有设备
    public void turnOffAll() {
        System.out.println("一键关闭所有设备：");
        light.turnOff();
        tv.turnOff();
        airConditioner.turnOff();
    }
}
```

#### 3. **客户端代码（Client）**

```java
public class Client {
    public static void main(String[] args) {
        // 创建智能家居控制中心
        SmartHomeFacade smartHome = new SmartHomeFacade();

        // 一键开启所有设备
        smartHome.turnOnAll();

        // 一键关闭所有设备
        smartHome.turnOffAll();
    }
}
```

#### 运行结果

```tex
一键开启所有设备：
灯光已打开
电视已打开
空调已打开
一键关闭所有设备：
灯光已关闭
电视已关闭
空调已关闭
```

### 优缺点分析

**优点：**

1. **简化接口**：外观模式通过外观类为复杂的子系统提供了一个简单的接口，方便客户端使用。
2. **降低耦合**：客户端只需要与外观类交互，而无需直接依赖子系统，从而降低了系统的耦合度。
3. **提高可维护性**：子系统的实现细节对客户端隐藏，客户端的改动不会影响子系统。

**缺点：**

1. **增加外观类的复杂性**：随着子系统功能的增加，外观类可能会变得臃肿，难以维护。
2. **限制子系统的灵活性**：客户端通过外观类与子系统交互，可能无法直接访问子系统的某些高级功能。

### 最佳实践

1. **避免过度设计**：只有当系统的子系统较为复杂，且客户端需要频繁交互时才使用外观模式。
2. **与其他模式结合使用**：外观模式可以与单例模式结合，确保外观类只有一个实例；也可以与策略模式结合，为不同客户端提供定制化的外观。
3. **保持外观类简洁**：外观类应该只负责简化接口，不应该承担太多的业务逻辑。

### 总结

外观模式通过引入一个外观类，为复杂的子系统提供了一个统一的接口，简化了客户端与子系统的交互。它不仅降低了系统的复杂性，还提升了代码的可维护性。在实际开发中，当系统变得复杂且子系统较多时，可以考虑使用外观模式来简化接口和降低耦合。

------

## 代理模式

### 代理模式：为对象提供一个替代品

#### 现实场景：酒店前台代理预定

假设你要预定一家酒店的房间，但是你并不直接与酒店的管理系统交互，而是通过酒店前台进行预定。在这种情况下，前台就是代理，它代替你向酒店管理系统请求房间，检查是否有空房，以及完成预定的流程。你只需要与前台交互，而不需要知道后端系统的具体操作。前台作为代理，通过简化操作、提供服务来帮助你完成预定。

### 什么是代理模式？

**代理模式（Proxy Pattern）** 是一种结构型设计模式，它通过一个代理对象来控制对目标对象的访问。代理对象充当目标对象的替代品，可能在访问目标对象之前或之后执行一些附加操作，比如权限检查、延迟加载、缓存等。

### 代理模式的核心角色

1. **目标对象（Real Subject）：**
   - 代理模式中的真实对象，代理对象通过它来访问目标。
2. **代理对象（Proxy）：**
   - 代理对象通过实现与目标对象相同的接口，控制客户端对目标对象的访问。代理对象可以在访问目标对象之前或之后执行额外的操作（如权限检查、延迟加载等）。
3. **客户端（Client）：**
   - 客户端通过代理对象与目标对象交互，客户端不直接与目标对象交互。

### 为什么使用代理模式？

1. **控制访问**：代理可以控制客户端对目标对象的访问，限制某些操作，确保系统的安全性。
2. **延迟加载**：代理对象可以延迟目标对象的创建和加载，直到真正需要时才进行操作。
3. **增强功能**：代理可以在不修改目标对象代码的情况下，增强目标对象的功能，如增加日志记录、安全检查、缓存等。
4. **解耦系统**：代理模式将客户端与目标对象之间的依赖关系解耦，客户端只需要与代理对象交互。

### 代理模式的实现方法

1. **定义目标对象接口**：目标对象和代理对象都实现相同的接口。
2. **定义代理对象类**：代理对象类持有目标对象的引用，并通过接口来访问目标对象。
3. **客户端代码**：客户端通过代理对象与目标对象交互，代理对象转发请求给目标对象。

### 示例：代客停车

假设你有一个汽车代客停车系统，它通过代理人来控制与停车场的交互。

#### 1. **目标对象（Real Subject）**

```java
// 真实的停车场，负责实际的停车操作
public class ParkingLot {
    public void parkCar(String car) {
        System.out.println(car + " 已停入停车位");
    }
}
```

#### 2. **代理对象（Proxy）**

```java
// 代理：代客停车服务
public class ValetParkingService {
    private ParkingLot parkingLot;

    public ValetParkingService(ParkingLot parkingLot) {
        this.parkingLot = parkingLot;
    }

    // 代客停车服务：将车停入停车场
    public void park(String car) {
        System.out.println("代客停车员正在为您停车...");
        parkingLot.parkCar(car);
    }
}
```

#### 3. **客户端代码（Client）**

```java
public class Client {
    public static void main(String[] args) {
        // 创建真实的停车场对象
        ParkingLot parkingLot = new ParkingLot();

        // 创建代理对象：代客停车服务
        ValetParkingService valetParkingService = new ValetParkingService(parkingLot);

        // 客户通过代理服务停车
        valetParkingService.park("我的车");
    }
}
```

#### 运行结果

```tex
代客停车员正在为您停车...
我的车 已停入停车位
```

### 优缺点分析

**优点：**

1. **控制访问**：代理对象可以控制访问权限，增强系统的安全性。
2. **简化操作**：代理模式可以简化客户端与目标对象的交互，客户端不需要关心目标对象的细节。
3. **延迟加载和性能优化**：代理模式可以延迟目标对象的加载，减少系统资源的消耗。

**缺点：**

1. **增加复杂性**：引入代理对象可能会导致系统的复杂性增加，尤其是在需要多层代理时。
2. **性能开销**：代理对象可能会引入额外的性能开销，尤其是在频繁操作时，代理对象的额外逻辑可能影响性能。

### 最佳实践

1. **避免过度代理**：仅在必要时使用代理模式，避免引入过多的代理层次。
2. **使用虚拟代理**：对于资源消耗较大的对象，可以采用虚拟代理延迟加载，从而提高系统性能。
3. **与其他模式结合使用**：代理模式可以与缓存模式、策略模式等结合，提供更灵活的控制方式。

### 总结

代理模式通过引入代理对象，控制客户端对目标对象的访问，增加了系统的灵活性和安全性。在实际开发中，代理模式可以用于权限控制、延迟加载、性能优化等场景。通过代理，客户端不需要直接操作目标对象，减少了复杂性并提升了可维护性。

------

## 桥接模式

### 桥接模式：将抽象与实现解耦

#### 现实场景：遥控器和家电

想象你有一台电视机和一台空调，它们有不同的品牌和型号，每个品牌和型号的遥控器控制方式可能不同。如果你每买一台新设备，就需要重新设计一套遥控器，显然不现实。为了解决这个问题，你可以通过一个统一的遥控器接口来控制不同的家电设备。这个遥控器可以适配不同的家电品牌和类型，这就是**桥接模式**的一个典型应用。通过桥接模式，遥控器和家电的抽象与实现部分被解耦，从而可以独立变化。

### 什么是桥接模式？

**桥接模式（Bridge Pattern）** 是一种结构型设计模式，它通过将抽象部分与实现部分分离，使得它们可以独立变化。桥接模式通过引入“桥接”接口来实现对不同实现的解耦，使得抽象和实现可以独立变化。

### 桥接模式的核心角色

1. **抽象类（Abstraction）：**
   - 定义了对客户端提供的操作接口，持有一个实现类的引用。
   - 可以扩展其他功能，通过委托给实现类来完成具体操作。
2. **扩展抽象类（Refined Abstraction）：**
   - 在抽象类的基础上，提供具体的实现，通常对外提供额外的业务逻辑。
3. **实现类接口（Implementor）：**
   - 定义具体的实现接口，不对外暴露任何抽象接口。
4. **具体实现类（Concrete Implementor）：**
   - 实现了实现类接口的具体类，完成具体的业务逻辑。

### 为什么使用桥接模式？

1. **解耦抽象和实现**：通过桥接模式，抽象和实现部分可以独立变化，从而减少了耦合。
2. **增加灵活性**：可以在不修改客户端代码的情况下，改变抽象部分或实现部分的具体实现。
3. **避免多层继承**：桥接模式通过组合而不是继承来实现功能扩展，避免了多层继承带来的复杂性。

### 桥接模式的实现方法

1. **定义抽象类**：抽象类持有一个实现类的引用，并委托实现类执行具体操作。
2. **定义实现类接口**：实现类接口定义了具体的操作方式。
3. **实现具体类**：具体实现类实现了实现类接口的具体方法。
4. **扩展抽象类**：扩展抽象类并提供具体的业务逻辑。

### 示例：遥控器和家电控制

假设我们需要控制多种类型的家电设备（如电视和空调），并且这些家电有不同的品牌（如三星、索尼等）。我们可以使用桥接模式来解耦遥控器的操作和家电设备的实现。

#### 1. **实现类接口（Implementor）**

```java
// 家电设备接口，定义所有家电应具备的方法
public interface Appliance {
    void turnOn();
    void turnOff();
}
```

#### 2. **具体实现类（Concrete Implementor）**

```java
// 电视设备
public class TV implements Appliance {
    @Override
    public void turnOn() {
        System.out.println("电视已打开");
    }

    @Override
    public void turnOff() {
        System.out.println("电视已关闭");
    }
}

// 空调设备
public class AirConditioner implements Appliance {
    @Override
    public void turnOn() {
        System.out.println("空调已打开");
    }

    @Override
    public void turnOff() {
        System.out.println("空调已关闭");
    }
}
```

#### 3. **抽象类（Abstraction）**

```java
// 遥控器接口，定义控制家电的操作
public abstract class RemoteControl {
    protected Appliance appliance;

    public RemoteControl(Appliance appliance) {
        this.appliance = appliance;
    }

    public abstract void turnOn();
    public abstract void turnOff();
}
```

#### 4. **扩展抽象类（Refined Abstraction）**

```java
// 具体遥控器，控制具体的家电设备
public class ConcreteRemoteControl extends RemoteControl {

    public ConcreteRemoteControl(Appliance appliance) {
        super(appliance);
    }

    @Override
    public void turnOn() {
        appliance.turnOn();
    }

    @Override
    public void turnOff() {
        appliance.turnOff();
    }
}
```

#### 5. **客户端代码（Client）**

```java
public class Client {
    public static void main(String[] args) {
        // 创建具体的家电对象（电视和空调）
        Appliance tv = new TV();
        Appliance airConditioner = new AirConditioner();

        // 创建遥控器对象
        RemoteControl tvRemote = new ConcreteRemoteControl(tv);
        RemoteControl acRemote = new ConcreteRemoteControl(airConditioner);

        // 控制家电设备
        tvRemote.turnOn(); // 输出：电视已打开
        acRemote.turnOff(); // 输出：空调已关闭
    }
}
```

#### 运行结果

```
电视已打开
空调已关闭
```

### 优缺点分析

**优点：**

1. **解耦抽象与实现**：通过桥接模式，抽象和实现部分可以独立变化，从而减少耦合。
2. **灵活性和可扩展性**：可以在不修改客户端代码的情况下，增加新的家电设备或遥控器。
3. **避免多层继承**：避免了在复杂情况下由于多层继承引起的复杂性。

**缺点：**

1. **增加系统复杂性**：由于需要定义多个类和接口，桥接模式的实现可能会增加系统的复杂性。
2. **过度设计**：在简单系统中使用桥接模式可能导致不必要的设计复杂性。

### 最佳实践

1. **适用于具有多变的维度的系统**：桥接模式适用于系统的多个维度（如设备类型、品牌等）独立变化的情况。
2. **避免过度使用**：对于简单的场景，使用桥接模式可能导致不必要的设计复杂性，因此需要权衡使用时机。
3. **结合策略模式使用**：桥接模式与策略模式可以结合使用，为不同的抽象部分提供更灵活的策略。

### 总结

桥接模式通过将抽象部分与实现部分分离，使得它们可以独立变化，从而减少了系统的耦合。通过桥接模式，可以灵活地扩展系统，增加新的家电设备或遥控器类型，而无需修改客户端代码。在实际开发中，桥接模式非常适用于那些具有多个维度和变化点的系统，如设备控制系统、图形绘制系统等。

------

## 组合模式

### 组合模式：树形结构中的对象组合

#### 现实场景：文件系统的文件夹与文件

想象一个操作系统的文件管理器。文件夹可以包含文件，也可以包含其他文件夹，而文件则不能再包含子文件。这种**“部分-整体”**的层次结构非常适合用**组合模式**来建模。文件夹和文件的操作（如查看名称、删除等）是相同的，用户只需调用相同的方法即可对文件和文件夹进行操作，而不必关心它们是“文件”还是“文件夹”。

### 什么是组合模式？

**组合模式（Composite Pattern）** 是一种结构型设计模式，它将对象组合成树形结构，以表示“部分-整体”的层次结构。通过组合模式，客户端可以使用统一的方式对单个对象和对象的组合进行操作。

### 组合模式的核心角色

1. **组件（Component）：**
   - 声明了对象的公共接口（如添加、删除子节点和显示信息等）。
   - 既可以表示**叶子对象**，也可以表示**容器对象**。
2. **叶子节点（Leaf）：**
   - 叶子节点是树的末端节点，**不包含子节点**。
   - 叶子节点继承自组件接口，但不能再包含子对象。
3. **容器节点（Composite）：**
   - 容器节点包含子节点（可以是**叶子节点**或**容器节点**）。
   - 容器节点提供了对子节点的**添加、删除和访问**的操作。
4. **客户端（Client）：**
   - 客户端通过组件接口与对象（无论是叶子还是容器）交互，**不需要关心对象是叶子还是容器**。

### 为什么使用组合模式？

1. **统一操作接口**：对“部分”和“整体”使用相同的接口，客户端不必区分是单个对象还是对象组合。
2. **树形结构的表示**：当需要表示文件系统、组织架构、菜单等层次结构时，组合模式是一种理想的选择。
3. **扩展性强**：通过增加新的叶子节点或容器节点，系统可以轻松扩展，符合**开闭原则**。

### 组合模式的实现方法

1. **定义组件接口**：声明统一的操作方法（如添加、删除、显示等）。
2. **实现叶子节点**：继承组件接口，代表“不可包含子节点的对象”。
3. **实现容器节点**：继承组件接口，**维护一个子节点的集合**，并实现对子节点的增删查操作。
4. **客户端操作**：客户端使用统一的接口来操作叶子节点和容器节点。

### 示例：文件系统的文件夹和文件

假设我们设计一个**文件系统**，它包括**文件（File）\**和\**文件夹（Folder）**。文件夹中可以包含文件和子文件夹。通过**组合模式**，我们可以设计一个统一的接口，让文件和文件夹的操作（如显示名称）具有一致性。

#### 1. **组件接口（Component）**

```java
// 抽象的组件类，声明了所有子类的公共操作
public abstract class FileSystemComponent {
    protected String name;

    public FileSystemComponent(String name) {
        this.name = name;
    }

    // 显示组件的名称
    public abstract void display();

    // 可选的增删操作，叶子节点不支持这些操作
    public void add(FileSystemComponent component) {
        throw new UnsupportedOperationException("不支持添加操作");
    }

    public void remove(FileSystemComponent component) {
        throw new UnsupportedOperationException("不支持删除操作");
    }
}
```

#### 2. **叶子节点（Leaf）**

```java
// 叶子节点，表示具体的文件
public class File extends FileSystemComponent {

    public File(String name) {
        super(name);
    }

    @Override
    public void display() {
        System.out.println("文件: " + name);
    }
}
```

#### 3. **容器节点（Composite）**

```java
// 容器节点，表示文件夹
import java.util.ArrayList;
import java.util.List;

public class Folder extends FileSystemComponent {
    private List<FileSystemComponent> children = new ArrayList<>();

    public Folder(String name) {
        super(name);
    }

    @Override
    public void display() {
        System.out.println("文件夹: " + name);
        for (FileSystemComponent component : children) {
            component.display();
        }
    }

    @Override
    public void add(FileSystemComponent component) {
        children.add(component);
    }

    @Override
    public void remove(FileSystemComponent component) {
        children.remove(component);
    }
}
```

#### 4. **客户端代码（Client）**

```java
public class Client {
    public static void main(String[] args) {
        // 创建叶子节点（文件）
        File file1 = new File("文档1.txt");
        File file2 = new File("图片1.png");
        File file3 = new File("视频1.mp4");

        // 创建容器节点（文件夹）
        Folder folder1 = new Folder("我的文档");
        Folder folder2 = new Folder("我的图片");
        Folder rootFolder = new Folder("根目录");

        // 组装文件系统
        folder1.add(file1);
        folder2.add(file2);
        folder2.add(file3);
        rootFolder.add(folder1);
        rootFolder.add(folder2);

        // 显示整个文件系统的结构
        rootFolder.display();
    }
}
```

#### 运行结果

```tex
文件夹: 根目录
  文件夹: 我的文档
    文件: 文档1.txt
  文件夹: 我的图片
    文件: 图片1.png
    文件: 视频1.mp4
```

### 优缺点分析

**优点：**

1. **清晰的树形结构**：可以清晰地表示“部分-整体”关系，便于管理和操作。
2. **客户端的透明性**：客户端只需调用“显示”操作，不需要区分叶子和容器。
3. **高扩展性**：可以轻松增加新的叶子和容器类型，遵循开闭原则。

**缺点：**

1. **不容易限制子组件**：如果需要限制某个容器只能包含某种特定类型的子对象，则需要额外的控制逻辑。
2. **增加复杂性**：需要定义较多的类和接口，且需要处理叶子和容器的差异。

### 最佳实践

1. **适用于“部分-整体”关系**：当一个系统需要表示“部分-整体”关系时，优先考虑使用组合模式。
2. **统一操作接口**：无论是叶子节点还是容器节点，操作都应具有一致的接口。
3. **避免滥用组合模式**：在简单的场景中，使用组合模式可能会导致不必要的设计复杂性。

### 总结

**组合模式**适用于具有**“部分-整体”**关系的系统，如**文件系统**、**组织架构**、**菜单系统**等。它通过**统一的接口**，使得**叶子节点**和**容器节点**的操作一致，客户端无需区分操作的是单个对象还是组合对象。通过组合模式，系统变得**清晰且易扩展**。如果你发现需要对**树形结构中的对象**进行**统一的操作**，那么组合模式是一个理想的选择。

------

## 享元模式

### 享元模式：对象共享，节省内存

#### 现实场景：文字处理软件的字符显示

在文字处理软件中，如 Word 或文本编辑器，文档中可能会有成千上万个**重复的字符**。如果每个字符都作为一个独立的对象来存储，将会消耗大量的内存资源。
**享元模式的核心思想**是：对于那些**可以复用的对象（如相同的字符）**，只创建一个对象，并将其在多个地方共享使用，从而节省内存。

**举个例子**：假设文档中有 1000 个字母 `A`，与其创建 1000 个 A 对象，不如只创建 1 个 A 对象，并在需要时**引用该对象**，这样就能节省内存。

### 什么是享元模式？

**享元模式（Flyweight Pattern）** 是一种结构型设计模式，**通过共享对象来减少内存消耗**。
在享元模式中，**相同的对象不会被重复创建**，而是被复用。对于那些外部状态（如位置、大小）不同的对象，外部状态会从共享对象中分离出来，由客户端独立存储。

**关键思想：将可共享的部分作为“内部状态”，将不共享的部分作为“外部状态”进行分离。**

### 享元模式的核心角色

1. **享元接口（Flyweight）：**
   - 定义了所有具体享元类的公共接口，通常包含操作方法。
2. **具体享元类（ConcreteFlyweight）：**
   - 实现享元接口，包含可共享的**内部状态**。
3. **不可共享的外部状态：**
   - 外部状态在**使用时动态传入**，不会保存在享元对象中。
4. **享元工厂（Flyweight Factory）：**
   - **管理和缓存享元对象**，当客户端请求时，工厂会检查对象池中是否已经存在所需的享元对象，如果有，则返回共享对象，如果没有，则创建一个新对象并返回。
5. **客户端（Client）：**
   - 客户端**区分内部状态和外部状态**，通过外部状态调用享元对象。

### 为什么使用享元模式？

1. **内存优化**：通过共享对象，减少内存中**相同对象的数量**，避免不必要的重复创建对象。
2. **性能提升**：减少垃圾回收（GC）压力，避免频繁地创建和销毁大量小对象。
3. **提高可维护性**：通过享元工厂对对象进行集中管理，便于对象的重用。

### 享元模式的实现方法

1. **定义享元接口**：定义对象的操作接口。
2. **实现具体享元类**：实现共享的具体对象，包含**内部状态**。
3. **实现享元工厂**：创建和缓存享元对象，控制对象的创建和复用。
4. **客户端使用**：通过工厂获取享元对象，并传入**外部状态**，与享元对象一起使用。

### 示例：文字处理软件中的字符共享

假设我们要设计一个文字处理系统，**每个字符是一个享元对象**。
字符的**字体（如大小、颜色、字体类型）是内部状态（共享部分）**，而**位置（如 x, y 坐标）是外部状态（不共享部分）**。

#### 1. **享元接口（Flyweight）**

```java
// 抽象的享元接口，定义了操作方法
public interface CharacterFlyweight {
    void display(int x, int y); // x 和 y 是外部状态，表示字符的位置
}
```

#### 2. **具体享元类（ConcreteFlyweight）**

```java
// 具体享元类，表示具体的字符
public class Character implements CharacterFlyweight {
    private char symbol;  // 内部状态，表示字符
    private String font;  // 内部状态，表示字体

    public Character(char symbol, String font) {
        this.symbol = symbol;
        this.font = font;
    }

    @Override
    public void display(int x, int y) {
        System.out.println("字符: " + symbol + "  字体: " + font + "  位置: (" + x + ", " + y + ")");
    }
}
```

#### 3. **享元工厂（Flyweight Factory）**

```java
import java.util.HashMap;
import java.util.Map;

// 享元工厂，管理和缓存享元对象
public class CharacterFactory {
    private Map<String, CharacterFlyweight> pool = new HashMap<>();

    // 获取享元对象，如果存在则返回，否则创建新对象并放入缓存
    public CharacterFlyweight getCharacter(char symbol, String font) {
        String key = symbol + "-" + font;  // 组合内在状态作为key
        if (!pool.containsKey(key)) {
            pool.put(key, new Character(symbol, font));
            System.out.println("创建了新字符对象: " + key);
        } else {
            System.out.println("复用现有字符对象: " + key);
        }
        return pool.get(key);
    }
}
```

#### 4. **客户端代码（Client）**

```java
public class Client {
    public static void main(String[] args) {
        CharacterFactory factory = new CharacterFactory();

        // 创建并复用相同的字符对象
        CharacterFlyweight a1 = factory.getCharacter('A', "Arial");
        a1.display(10, 20); // 位置是外部状态

        CharacterFlyweight a2 = factory.getCharacter('A', "Arial");
        a2.display(30, 40); // 位置是外部状态

        CharacterFlyweight b1 = factory.getCharacter('B', "Arial");
        b1.display(50, 60); // 新的 'B' 对象

        CharacterFlyweight a3 = factory.getCharacter('A', "Times New Roman");
        a3.display(70, 80); // 新的字体，因此会创建一个新的对象
    }
}
```

#### 运行结果

```tex
创建了新字符对象: A-Arial
字符: A  字体: Arial  位置: (10, 20)
复用现有字符对象: A-Arial
字符: A  字体: Arial  位置: (30, 40)
创建了新字符对象: B-Arial
字符: B  字体: Arial  位置: (50, 60)
创建了新字符对象: A-Times New Roman
字符: A  字体: Times New Roman  位置: (70, 80)
```

> 解释：
>
> - 第一次获取 A-Arial 时，创建了新对象。
> - 第二次获取 A-Arial，直接复用之前的对象。
> - 获取 B-Arial，创建了新对象。
> - 获取 A-Times New Roman，因为字体不同，所以是一个新对象。

### 优缺点分析

**优点：**

1. **减少内存消耗**：共享对象，减少对象数量，节省内存。
2. **减少对象的创建销毁开销**：对象复用，降低 GC 压力，提高系统性能。
3. **集中管理**：通过工厂管理对象，便于控制对象的生命周期。

**缺点：**

1. **外部状态的管理复杂**：外部状态的分离，可能会增加代码的复杂性。
2. **不适用于变化过多的场景**：如果对象的内部状态变化频繁，使用享元模式的效果会下降。
3. **线程安全问题**：如果多个线程同时访问共享对象，可能会有线程安全问题。

### 最佳实践

1. **避免滥用**：享元模式适用于大量的**小型对象**，如果对象的状态过多或变化频繁，则不适合。
2. **与工厂模式结合**：工厂管理享元对象，避免客户端直接控制对象的创建。
3. **确保线程安全**：对于共享的享元对象，确保线程安全性。

### 总结

**享元模式**通过共享**相同的对象**，**减少内存占用**，并将**不变的内部状态**与**可变的外部状态**分离。
当系统中存在**大量小对象**，且这些对象有许多**可共享的部分**时，使用享元模式可以显著**节省内存和提高性能**。

**适用场景**：文字处理软件、图形编辑器的图元、网络连接池、棋盘游戏的棋子等。
如果你发现系统中有许多**相同的对象**，而这些对象的某些状态是可共享的，考虑使用**享元模式**来优化内存和性能。

