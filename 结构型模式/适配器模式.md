## 适配器模式

### 适配器模式：让不兼容的接口兼容

#### 现实场景：电源插座适配器

假设你旅行到另一个国家，发现你带的电器插头和当地的电源插座不兼容。为了让电器能够正常使用，你需要一个插座适配器，它能够将你的电器插头转换成适合当地插座的类型。这就是**适配器模式**的一个典型应用，适配器充当了不同接口之间的桥梁。

### 什么是适配器模式？

**适配器模式（Adapter Pattern）** 是一种结构型设计模式，它允许将一个类的接口转换成客户端所期望的另一个接口。适配器模式使得原本由于接口不兼容而无法一起工作的类能够协同工作。它的核心思想是：通过一个适配器，将原接口适配成目标接口，以实现不同接口之间的兼容。

### 适配器模式的核心角色

1. **目标接口（Target）：**
    - 客户端所期望的接口，也就是需要适配的接口。客户端会与目标接口交互。
2. **源接口（Adaptee）：**
    - 需要被适配的接口。该接口在系统中已有，但与目标接口不兼容。
3. **适配器（Adapter）：**
    - 适配器通过实现目标接口，并将请求委托给源接口，从而适配源接口和目标接口。适配器将源接口的方法转换为目标接口所期望的形式。

### 为什么使用适配器模式？

1. **接口不兼容**：当你需要集成的类接口不兼容时，使用适配器模式可以将其转化为目标接口，确保两者能够兼容。
2. **复用现有代码**：适配器模式通过适配器的方式，使得已有的类可以在新的环境下使用，避免了重新编写大量的代码。
3. **系统解耦**：通过引入适配器，可以将不同模块之间的耦合关系减少，使得系统更加灵活和可扩展。

### 适配器模式的实现方法

1. **目标接口**：定义客户端所期望的接口。
2. **源接口**：定义现有的不兼容接口。
3. **适配器**：实现目标接口，并将请求委托给源接口。

### 示例：电源插座适配器

假设我们有不同类型的插座，客户端需要插入两种不同类型的插头。为了让这些插头能够兼容，我们设计一个适配器类来适配插座。

#### 1. **目标接口（Target）**

```java
// 电源接口：客户端期望的接口
public interface PowerSocket {
    void plugIn();  // 客户端希望使用的方法
}
```

#### 2. **源接口（Adaptee）**

```java
// 旧插座接口：现有的接口（需要适配）
public class OldPowerSocket {
    public void insert() {
        System.out.println("插头插入到旧插座");
    }
}
```

#### 3. **适配器（Adapter）**

```java
// 适配器类，将旧插座的接口适配成目标接口
public class PowerAdapter implements PowerSocket {
    private OldPowerSocket oldPowerSocket;  // 源接口（旧插座）

    public PowerAdapter(OldPowerSocket oldPowerSocket) {
        this.oldPowerSocket = oldPowerSocket;
    }

    // 将旧插座的 insert 方法适配为目标接口的 plugIn 方法
    @Override
    public void plugIn() {
        oldPowerSocket.insert();  // 委托调用旧插座的方法
    }
}
```

#### 4. **客户端代码**

```java
public class Client {
    public static void main(String[] args) {
        // 旧插座
        OldPowerSocket oldSocket = new OldPowerSocket();

        // 创建适配器，适配旧插座
        PowerSocket adapter = new PowerAdapter(oldSocket);

        // 客户端通过目标接口使用插座
        adapter.plugIn();  // 输出：插头插入到旧插座
    }
}
```

#### 运行结果

```tex
插头插入到旧插座
```

### 优缺点分析

**优点**：

1. **提高系统的灵活性**：通过适配器模式，可以让不兼容的接口协同工作，使系统更加灵活。
2. **重用现有类**：适配器模式可以将已经存在的类通过适配器与新的接口兼容，而无需修改原有类。
3. **减少类的数量**：通过引入适配器，而不是直接修改源类，可以减少新增类的数量。

**缺点**：

1. **增加系统复杂性**：引入适配器类后，会增加类的数量，使得系统的结构变得更加复杂。
2. **性能开销**：适配器模式引入了一层适配器，这可能会带来一些性能开销，尤其在频繁调用时。

### 最佳实践

1. **只在接口不兼容时使用**：适配器模式主要用于解决接口不兼容问题，如果接口本身可以兼容，最好不要引入适配器。
2. **避免过度适配**：如果适配器层次过深，可能导致代码过于复杂，最好通过简单的接口设计避免这种情况。
3. **适配器与多态结合**：适配器模式与多态结合使用时，可以灵活处理不同的对象，使得客户端可以通过统一的接口与不同的类进行交互。

### 总结

适配器模式通过引入适配器类，将不兼容的接口转换为客户端所期望的目标接口。它能够让不同接口的类协同工作，并且有助于复用已有代码。适配器模式特别适用于当已有系统中的接口不兼容时，或者需要集成多个第三方库时。不过，适配器模式也可能带来一定的性能开销，因此需要谨慎使用。

