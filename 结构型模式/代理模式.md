## 代理模式

### 代理模式：为对象提供一个替代品

#### 现实场景：酒店前台代理预定

假设你要预定一家酒店的房间，但是你并不直接与酒店的管理系统交互，而是通过酒店前台进行预定。在这种情况下，前台就是代理，它代替你向酒店管理系统请求房间，检查是否有空房，以及完成预定的流程。你只需要与前台交互，而不需要知道后端系统的具体操作。前台作为代理，通过简化操作、提供服务来帮助你完成预定。

### 什么是代理模式？

**代理模式（Proxy Pattern）** 是一种结构型设计模式，它通过一个代理对象来控制对目标对象的访问。代理对象充当目标对象的替代品，可能在访问目标对象之前或之后执行一些附加操作，比如权限检查、延迟加载、缓存等。

### 代理模式的核心角色

1. **目标对象（Real Subject）：**
    - 代理模式中的真实对象，代理对象通过它来访问目标。
2. **代理对象（Proxy）：**
    - 代理对象通过实现与目标对象相同的接口，控制客户端对目标对象的访问。代理对象可以在访问目标对象之前或之后执行额外的操作（如权限检查、延迟加载等）。
3. **客户端（Client）：**
    - 客户端通过代理对象与目标对象交互，客户端不直接与目标对象交互。

### 为什么使用代理模式？

1. **控制访问**：代理可以控制客户端对目标对象的访问，限制某些操作，确保系统的安全性。
2. **延迟加载**：代理对象可以延迟目标对象的创建和加载，直到真正需要时才进行操作。
3. **增强功能**：代理可以在不修改目标对象代码的情况下，增强目标对象的功能，如增加日志记录、安全检查、缓存等。
4. **解耦系统**：代理模式将客户端与目标对象之间的依赖关系解耦，客户端只需要与代理对象交互。

### 代理模式的实现方法

1. **定义目标对象接口**：目标对象和代理对象都实现相同的接口。
2. **定义代理对象类**：代理对象类持有目标对象的引用，并通过接口来访问目标对象。
3. **客户端代码**：客户端通过代理对象与目标对象交互，代理对象转发请求给目标对象。

### 示例：代客停车

假设你有一个汽车代客停车系统，它通过代理人来控制与停车场的交互。

#### 1. **目标对象（Real Subject）**

```java
// 真实的停车场，负责实际的停车操作
public class ParkingLot {
    public void parkCar(String car) {
        System.out.println(car + " 已停入停车位");
    }
}
```

#### 2. **代理对象（Proxy）**

```java
// 代理：代客停车服务
public class ValetParkingService {
    private ParkingLot parkingLot;

    public ValetParkingService(ParkingLot parkingLot) {
        this.parkingLot = parkingLot;
    }

    // 代客停车服务：将车停入停车场
    public void park(String car) {
        System.out.println("代客停车员正在为您停车...");
        parkingLot.parkCar(car);
    }
}
```

#### 3. **客户端代码（Client）**

```java
public class Client {
    public static void main(String[] args) {
        // 创建真实的停车场对象
        ParkingLot parkingLot = new ParkingLot();

        // 创建代理对象：代客停车服务
        ValetParkingService valetParkingService = new ValetParkingService(parkingLot);

        // 客户通过代理服务停车
        valetParkingService.park("我的车");
    }
}
```

#### 运行结果

```tex
代客停车员正在为您停车...
我的车 已停入停车位
```

### 优缺点分析

**优点：**

1. **控制访问**：代理对象可以控制访问权限，增强系统的安全性。
2. **简化操作**：代理模式可以简化客户端与目标对象的交互，客户端不需要关心目标对象的细节。
3. **延迟加载和性能优化**：代理模式可以延迟目标对象的加载，减少系统资源的消耗。

**缺点：**

1. **增加复杂性**：引入代理对象可能会导致系统的复杂性增加，尤其是在需要多层代理时。
2. **性能开销**：代理对象可能会引入额外的性能开销，尤其是在频繁操作时，代理对象的额外逻辑可能影响性能。

### 最佳实践

1. **避免过度代理**：仅在必要时使用代理模式，避免引入过多的代理层次。
2. **使用虚拟代理**：对于资源消耗较大的对象，可以采用虚拟代理延迟加载，从而提高系统性能。
3. **与其他模式结合使用**：代理模式可以与缓存模式、策略模式等结合，提供更灵活的控制方式。

### 总结

代理模式通过引入代理对象，控制客户端对目标对象的访问，增加了系统的灵活性和安全性。在实际开发中，代理模式可以用于权限控制、延迟加载、性能优化等场景。通过代理，客户端不需要直接操作目标对象，减少了复杂性并提升了可维护性。

