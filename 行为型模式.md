# 行为型模式

## 责任链模式

### 责任链模式：请求的链式传递

#### 现实场景：客户服务的多级客服系统

想象一下，当您向某家电公司的客户服务中心求助时，系统会首先将您的请求发送给**初级客服**，如果初级客服无法解决问题，则请求被传递给**高级客服**，如果高级客服仍然无法解决，则请求可能会被发送到**技术支持工程师**。
在这个场景中，**每一层的客服都在处理请求，直到某一层能够处理它为止**。这就是**责任链模式**的典型场景。

### 什么是责任链模式？

**责任链模式（Chain of Responsibility Pattern）** 是一种行为型设计模式，**将请求沿着一条链传递，直到某个对象处理它为止**。
在责任链模式中，多个**处理者（Handler）** 按照**链式结构**连接在一起，**每个处理者**都有机会对请求进行处理，或者将请求传递给**链中的下一个处理者**。

**核心思想：请求者不需要知道请求是由哪一个具体的处理者来处理的，减少了请求发送者和处理者之间的耦合。**

### 责任链模式的核心角色

1. **抽象处理者（Handler）**：
   - 定义一个处理请求的接口，包含一个**指向下一个处理者的引用**。
   - 定义了**处理请求的方法**，通常是 `handleRequest()`。
2. **具体处理者（Concrete Handler）**：
   - 继承抽象处理者，具体实现对请求的处理逻辑。
   - 如果当前处理者无法处理请求，则将请求**传递给下一个处理者**。
3. **客户端（Client）**：
   - 客户端创建责任链，并将请求发送给链中的第一个处理者。
4. **请求（Request）**：
   - 请求是由客户端发出的，需要被链中的某个处理者处理。

### 为什么使用责任链模式？

1. **降低耦合性**：请求的发送者和接收者解耦，发送者不需要指定具体的请求处理者。
2. **灵活的链式结构**：链的结构可以动态改变（添加、删除或重新排列处理者）。
3. **增强系统的可扩展性**：通过添加新的处理者类，不需要修改现有的系统。

### 责任链模式的实现方法

1. **定义抽象处理者**：提供一个指向**下一个处理者的引用**，并定义一个**处理请求的方法**。
2. **实现具体处理者**：实现具体的处理逻辑，如果无法处理请求，则将请求传递给下一个处理者。
3. **构建链式结构**：将多个具体的处理者按链式结构连接起来。
4. **客户端发送请求**：客户端将请求传递给链中的第一个处理者，链上的处理者依次对请求进行处理。

### 示例：客户服务的多级客服系统

假设我们设计一个客户服务系统，**初级客服**处理简单问题，**高级客服**处理中等难度问题，而**技术支持**负责解决高级问题。
客户的请求包含一个**难度级别**，如果初级客服无法处理，**请求将被传递到高级客服**，如果高级客服仍无法处理，则交由**技术支持工程师**。

#### 1. **抽象处理者（Handler）**

```java
// 抽象的处理者，定义了处理请求的方法和责任链的下一个处理者
public abstract class CustomerServiceHandler {
    protected CustomerServiceHandler nextHandler;

    // 设置下一个处理者
    public void setNextHandler(CustomerServiceHandler nextHandler) {
        this.nextHandler = nextHandler;
    }

    // 处理请求的抽象方法
    public abstract void handleRequest(int difficultyLevel);
}
```

#### 2. **具体处理者（Concrete Handler）**

```java
// 初级客服，处理难度为 1 及以下的问题
public class JuniorSupport extends CustomerServiceHandler {
    @Override
    public void handleRequest(int difficultyLevel) {
        if (difficultyLevel <= 1) {
            System.out.println("初级客服已处理了难度为 " + difficultyLevel + " 的请求。");
        } else if (nextHandler != null) {
            System.out.println("初级客服无法处理，转交给高级客服...");
            nextHandler.handleRequest(difficultyLevel);
        }
    }
}

// 高级客服，处理难度为 2 及以下的问题
public class SeniorSupport extends CustomerServiceHandler {
    @Override
    public void handleRequest(int difficultyLevel) {
        if (difficultyLevel <= 2) {
            System.out.println("高级客服已处理了难度为 " + difficultyLevel + " 的请求。");
        } else if (nextHandler != null) {
            System.out.println("高级客服无法处理，转交给技术支持...");
            nextHandler.handleRequest(difficultyLevel);
        }
    }
}

// 技术支持，处理所有难度的问题
public class TechSupport extends CustomerServiceHandler {
    @Override
    public void handleRequest(int difficultyLevel) {
        System.out.println("技术支持已处理了难度为 " + difficultyLevel + " 的请求。");
    }
}
```

#### 3. **客户端代码（Client）**

```java
public class Client {
    public static void main(String[] args) {
        // 创建责任链的处理者
        CustomerServiceHandler juniorSupport = new JuniorSupport();
        CustomerServiceHandler seniorSupport = new SeniorSupport();
        CustomerServiceHandler techSupport = new TechSupport();

        // 构建链式结构：初级客服 -> 高级客服 -> 技术支持
        juniorSupport.setNextHandler(seniorSupport);
        seniorSupport.setNextHandler(techSupport);

        // 客户请求不同难度的服务
        System.out.println("客户请求难度 1 的服务：");
        juniorSupport.handleRequest(1);
        
        System.out.println("\n客户请求难度 2 的服务：");
        juniorSupport.handleRequest(2);
        
        System.out.println("\n客户请求难度 3 的服务：");
        juniorSupport.handleRequest(3);
    }
}
```

#### 运行结果

```tex
客户请求难度 1 的服务：
初级客服已处理了难度为 1 的请求。

客户请求难度 2 的服务：
初级客服无法处理，转交给高级客服...
高级客服已处理了难度为 2 的请求。

客户请求难度 3 的服务：
初级客服无法处理，转交给高级客服...
高级客服无法处理，转交给技术支持...
技术支持已处理了难度为 3 的请求。
```

### 优缺点分析

**优点：**

1. **请求与处理者解耦**：客户端不需要指定哪个处理者处理请求，减少了系统的耦合性。
2. **链的灵活性**：可以灵活地**添加、删除或重排责任链中的处理者**，无需修改现有的代码。
3. **职责分离**：每个处理者只专注于自己能处理的请求，便于代码的扩展和维护。

**缺点：**

1. **请求的处理时间不确定**：请求可能要传递很多次，导致处理的延迟。
2. **调试困难**：如果链太长或结构复杂，调试和排查问题会很困难。

### 最佳实践

1. **链的顺序应合理**：应将最有可能处理请求的**处理者放在链的前面**，以减少不必要的传递。
2. **不要过长的链**：如果责任链过长，可能会**影响性能**，可以考虑**分段链**的设计。
3. **异常处理**：责任链中可能会有一些**未处理的请求**，在链末尾可以添加一个“默认处理者”来记录这些未被处理的请求。

### 总结

**责任链模式**将请求传递给一系列**处理者对象**，使多个对象有机会处理请求，客户端不需要知道谁是最终的处理者。
**使用场景**：

- 多级审批流程（如请假流程）
- 日志系统（不同级别的日志记录器）
- Web 框架中的中间件（如请求过滤器）

**核心点**：降低了请求发送者与接收者的耦合度，处理者链可以灵活调整，便于扩展和维护。

------

## 命令模式

### 命令模式：将请求封装成对象

#### 现实场景：外卖点餐系统

想象一个**外卖点餐系统**，当你在手机App中选择了几道菜并提交订单时，后台会将**每道菜的制作请求发送给不同的餐厅厨房**。
在这里，每道菜的制作请求就是一个**命令**。
每个菜都有**名称（如“宫保鸡丁”）、数量（如2份）和操作（如制作、取消等）**。
**命令模式**的核心思想是**将请求（制作宫保鸡丁）封装为一个独立的命令对象**，便于请求的**存储、撤销和重做**。

### 什么是命令模式？

**命令模式（Command Pattern）** 是一种**行为型设计模式**，它**将请求封装成命令对象**，从而使请求可以**被参数化、记录日志、撤销和排队**。
命令对象不仅**包含了请求的动作**，还包含了**接收者和操作的参数**，这使得**请求的发起者和请求的执行者解耦**。

**核心思想：**

1. **将操作封装为对象**，操作不再是直接调用方法，而是调用命令对象的`execute()`方法。
2. **支持请求的撤销、重做和排队**。

### 命令模式的核心角色

1. **命令接口（Command）：**
   - 定义一个**执行操作的接口**，所有的命令类都实现这个接口。
2. **具体命令（Concrete Command）：**
   - 实现命令接口，定义请求的具体操作，比如**制作宫保鸡丁、制作麻婆豆腐等**。
3. **接收者（Receiver）：**
   - 命令的实际执行者，比如**餐厅的厨房**，当接收到“制作宫保鸡丁”命令时，厨房会开始制作。
4. **调用者（Invoker）：**
   - **发出请求的对象**，比如**顾客**或**订单系统**，它负责将请求转换为命令，并将命令交给接收者去执行。
5. **客户端（Client）：**
   - 创建命令对象和调用者，并发起请求。

### 为什么使用命令模式？

1. **解耦请求的发起者和接收者**：命令的发出者（如顾客）和命令的执行者（如厨房）被解耦，客户端不需要直接与接收者交互。
2. **支持撤销和重做**：可以轻松实现撤销、重做操作（如取消订单、重新下单）。
3. **支持命令的排队和日志记录**：命令对象可以存储到队列中，从而实现请求的**延迟执行、日志记录和批处理**。

### 命令模式的实现方法

1. **定义命令接口**，所有命令类都要实现这个接口。
2. **实现具体命令类**，封装请求的具体操作（如制作菜品）。
3. **定义接收者类**，执行实际操作（如厨房负责制作菜品）。
4. **定义调用者类**，接收命令并触发其`execute()`方法。

### 示例：外卖点餐系统

我们将实现一个**外卖点餐系统**，它能够：

1. **点菜**：用户可以点**宫保鸡丁、麻婆豆腐和鱼香肉丝**等菜品。
2. **取消订单**：用户可以取消已经提交的订单。
3. **支持操作的撤销**：如果用户点击了“撤销”，则可以恢复上一次的操作。

#### 1. **命令接口（Command）**

```java
// 命令接口，定义一个执行操作的接口
public interface Command {
    void execute();
    void undo();
}
```

#### 2. **具体命令（Concrete Command）**

```java
// 具体的命令：制作宫保鸡丁
public class KungPaoChickenCommand implements Command {
    private KitchenReceiver kitchen;

    public KungPaoChickenCommand(KitchenReceiver kitchen) {
        this.kitchen = kitchen;
    }

    @Override
    public void execute() {
        kitchen.cookKungPaoChicken();
    }

    @Override
    public void undo() {
        kitchen.cancelKungPaoChicken();
    }
}

// 具体的命令：制作麻婆豆腐
public class MapoTofuCommand implements Command {
    private KitchenReceiver kitchen;

    public MapoTofuCommand(KitchenReceiver kitchen) {
        this.kitchen = kitchen;
    }

    @Override
    public void execute() {
        kitchen.cookMapoTofu();
    }

    @Override
    public void undo() {
        kitchen.cancelMapoTofu();
    }
}
```

#### 3. **接收者（Receiver）**

```java
// 接收者：厨房
public class KitchenReceiver {
    public void cookKungPaoChicken() {
        System.out.println("制作宫保鸡丁...");
    }

    public void cancelKungPaoChicken() {
        System.out.println("取消宫保鸡丁...");
    }

    public void cookMapoTofu() {
        System.out.println("制作麻婆豆腐...");
    }

    public void cancelMapoTofu() {
        System.out.println("取消麻婆豆腐...");
    }
}
```

#### 4. **调用者（Invoker）**

```java
// 调用者：订单系统
public class OrderInvoker {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void executeCommand() {
        command.execute();
    }

    public void undoCommand() {
        command.undo();
    }
}
```

#### 5. **客户端代码（Client）**

```java
public class Client {
    public static void main(String[] args) {
        // 创建接收者（厨房）
        KitchenReceiver kitchen = new KitchenReceiver();

        // 创建命令
        Command kungPaoChickenCommand = new KungPaoChickenCommand(kitchen);
        Command mapoTofuCommand = new MapoTofuCommand(kitchen);

        // 创建调用者（订单系统）
        OrderInvoker orderInvoker = new OrderInvoker();

        // 顾客点了宫保鸡丁
        orderInvoker.setCommand(kungPaoChickenCommand);
        orderInvoker.executeCommand();

        // 顾客点了麻婆豆腐
        orderInvoker.setCommand(mapoTofuCommand);
        orderInvoker.executeCommand();

        // 撤销上一个操作
        orderInvoker.undoCommand();
    }
}
```

#### 运行结果

```tex
制作宫保鸡丁...
制作麻婆豆腐...
取消麻婆豆腐...
```

### 优缺点分析

**优点：**

1. **解耦请求发起者和请求执行者**：命令对象封装了请求，调用者和接收者互不依赖。
2. **支持撤销和重做**：只需要调用命令的`undo()`方法即可实现撤销操作。
3. **命令的可扩展性强**：如果需要支持新功能（例如新菜品），只需增加**新命令类**，不需要修改原有代码。

**缺点：**

1. **命令数量多**：每个请求都需要单独的命令类，可能会导致类的数量急剧增加。

### 总结

命令模式的核心是**将请求封装为命令对象**，使得请求的**发起者和接收者解耦**，并支持**撤销、重做、排队和日志**。
在**外卖系统、遥控器控制、事务系统**中，命令模式被广泛应用。
当你希望**记录请求操作、支持撤销和重做操作**时，可以考虑使用命令模式。

------

## 解释器模式

### 解释器模式：自然语言处理中的关键词解析

#### 现实场景：语音助手命令解析

在日常生活中，我们常常使用语音助手来执行各种任务，如设定闹钟、播放音乐、查询天气等。语音助手需要解析用户的命令并执行相应的操作。例如，用户说“明天早上7点提醒我开会”，语音助手需要解析命令中的时间、事件类型等信息，并在正确的时间触发相应的提醒功能。

使用**解释器模式**，可以将这些复杂的命令解析过程组织起来，使得每个命令的解析和执行变得更为清晰和灵活。解释器模式能够将自然语言命令（如“设置闹钟”或“播放音乐”）转换为计算机能够理解和处理的具体操作。

### 什么是解释器模式？

**解释器模式（Interpreter Pattern）** 是一种**行为型设计模式**，用于**定义自然语言的语法表示**，并**提供一个解释器来对输入语句进行求值**。
简单来说，**解释器模式将语言的语法转化为可执行的操作**，并通过解释器执行操作。

**核心思想：**

1. **定义一套可识别的命令语法**，
2. **为语法中的每个关键部分创建解释器类**，
3. **使用解释器将命令转化为具体的可执行操作**。

### 解释器模式的核心角色

1. **抽象表达式（AbstractExpression）**：
   - 定义解释操作的抽象接口，所有表达式类都要实现这个接口。
2. **终结符表达式（TerminalExpression）**：
   - 语句中的基本元素，例如**“灯”、“音乐”**等，这些是具体的操作。
3. **非终结符表达式（NonTerminalExpression）**：
   - 由多个终结符和操作符组成的复杂命令，例如**“打开卧室的灯并播放音乐”**。
4. **上下文（Context）**：
   - 解释器的**上下文环境**，存储了解释过程中所需的变量和操作。
5. **客户端（Client）**：
   - 负责**输入命令并请求解释器解析**命令的含义。

### 为什么使用解释器模式？

1. **解析自然语言命令**：用于实现**语音助手的命令解析、聊天机器人的语句解析**等场景。
2. **实现可扩展的命令体系**：通过解释器类的扩展，可以轻松支持**新命令和新语法**。
3. **解耦命令和操作**：将命令的**定义和解释**与**实际操作的实现**分离，增强了灵活性和可维护性。

### 解释器模式的实现方法

1. **定义抽象表达式类**：声明解释操作的接口。
2. **实现终结符表达式类**：表示具体的命令（如“灯”、“音乐”）。
3. **实现非终结符表达式类**：表示操作符（如“打开”、“播放”）。
4. **定义上下文类**：存储解释命令时所需的上下文信息。
5. **客户端**：输入语音命令，调用解释器对其进行解析和求值。

### 示例：智能语音助手的命令解析

#### 1. **抽象表达式（AbstractExpression）**

```java
public interface Expression {
    void interpret(Context context);
}
```

#### 2. **终结符表达式（TerminalExpression）**

```java
// 表示具体的命令：打开灯
public class TurnOnLightExpression implements Expression {
    @Override
    public void interpret(Context context) {
        System.out.println("执行操作：打开卧室的灯");
    }
}

// 表示具体的命令：播放音乐
public class PlayMusicExpression implements Expression {
    @Override
    public void interpret(Context context) {
        System.out.println("执行操作：播放音乐");
    }
}
```

#### 3. **非终结符表达式（NonTerminalExpression）**

```java
// 复合命令：表示“打开卧室的灯并播放音乐”
public class AndExpression implements Expression {
    private Expression expr1;
    private Expression expr2;

    public AndExpression(Expression expr1, Expression expr2) {
        this.expr1 = expr1;
        this.expr2 = expr2;
    }

    @Override
    public void interpret(Context context) {
        expr1.interpret(context);
        expr2.interpret(context);
    }
}
```

#### 4. **上下文类（Context）**

```java
public class Context {
    // 上下文中可以存储一些解释器执行所需的信息
    private String input;

    public Context(String input) {
        this.input = input;
    }

    public String getInput() {
        return input;
    }
}
```

#### 5. **客户端代码（Client）**

```java
public class Client {
    public static void main(String[] args) {
        // 上下文中包含了用户的语音命令
        Context context = new Context("打开卧室的灯并播放音乐");

        // 创建解释器
        Expression turnOnLight = new TurnOnLightExpression();
        Expression playMusic = new PlayMusicExpression();

        // 组合命令：打开灯 + 播放音乐
        Expression combinedCommand = new AndExpression(turnOnLight, playMusic);

        // 解释并执行命令
        combinedCommand.interpret(context);
    }
}
```

#### **运行结果**

```
执行操作：打开卧室的灯
执行操作：播放音乐
```

### 优缺点分析

**优点：**

1. **语法扩展性强**：只需增加新的表达式类（如“开窗”），即可扩展新命令。
2. **解耦语法和操作**：将“语法规则的定义”和“语法的执行”解耦，便于扩展和维护。
3. **可读性强**：通过类的继承关系，清晰地表示了命令的语法结构。

**缺点：**

1. **类的数量增多**：每种新语法都需要一个类，系统复杂性会增加。
2. **性能开销大**：如果命令频繁解析，会增加系统开销。

### 最佳实践

1. **适用于小型语法系统**：如果系统的语法规则过于复杂，解释器会变得庞大而难以维护。
2. **与其他模式结合使用**：可以与**组合模式**结合，使用组合结构来解析复合命令。
3. **避免类爆炸**：如果语法规则过多，可能需要使用动态解释器，避免大量的表达式类。

### 总结

**解释器模式**提供了一种**将语法规则转化为可执行操作的方式**。
在**语音助手命令解析、聊天机器人、SQL解析器、编译器设计**等场景中经常使用。
通过将**语法与操作分离**，解释器使得**语法的扩展变得简单**，但也可能导致**类的数量激增**，需要在项目中合理使用。

------

## 迭代器模式

### 迭代器模式：逐一访问集合中的元素

#### 现实场景：图书馆的图书浏览器

想象你在图书馆里，书架上摆满了各种书籍。
如果你想要**逐本查看**每一本书，你可能会从左到右一一浏览。
在这种情况下，**书架就是一个“集合”，你就是“迭代器”，你通过一个统一的方式来遍历书籍，而不需要关心书籍的排列方式或数据存储结构**。

### 什么是迭代器模式？

**迭代器模式（Iterator Pattern）** 是一种**行为型设计模式**，用于**遍历集合中的元素**，而不需要暴露集合的内部结构。
它为集合提供了一种**统一的遍历接口**，使得不同类型的集合都可以以一致的方式进行遍历。

**核心思想：**

1. **隐藏集合的内部实现**，客户端不需要知道集合是数组、链表还是其他数据结构。
2. **提供一个统一的遍历接口**，使用“`next()`”、“`hasNext()`”等方法来遍历集合中的元素。

### 迭代器模式的核心角色

1. **迭代器接口（Iterator）**：
   - 声明用于遍历集合的方法，例如`hasNext()`、`next()`、`remove()`等。
2. **具体迭代器（ConcreteIterator）**：
   - 实现迭代器接口，负责遍历集合中的元素，并记录当前遍历的位置。
3. **集合接口（Aggregate）**：
   - 声明**创建迭代器对象的方法**，通常是`createIterator()`。
4. **具体集合（ConcreteAggregate）**：
   - 实现集合接口，存储元素，并返回一个具体的迭代器实例来遍历这些元素。
5. **客户端（Client）**：
   - 通过迭代器访问集合中的元素，而不需要知道集合的内部结构。

### 为什么使用迭代器模式？

1. **统一的遍历接口**：无论集合是数组、链表还是其他数据结构，都能通过统一的接口`hasNext()`和`next()`来遍历元素。
2. **隐藏集合的内部实现**：客户端只关心如何遍历，而不关心集合的存储方式。
3. **解耦遍历逻辑和集合实现**：迭代器模式将“**集合的存储**”和“**集合的遍历**”分离，便于修改集合的实现。

### 迭代器模式的实现方法

1. **定义迭代器接口**：提供`hasNext()`、`next()`等遍历方法。
2. **实现具体的迭代器类**：维护遍历状态（如当前索引），并实现`hasNext()`、`next()`。
3. **定义集合接口**：定义方法`createIterator()`来返回一个迭代器。
4. **实现具体的集合类**：实现集合接口，存储元素，并创建迭代器对象来遍历元素。

### 示例：图书馆的图书浏览器

我们将实现一个**图书馆的书架系统**，用户可以通过迭代器**逐一浏览书籍**。

#### 1. **迭代器接口（Iterator）**

```java
public interface Iterator {
    boolean hasNext();   // 是否还有下一个元素
    Object next();       // 获取下一个元素
}
```

#### 2. **具体迭代器（ConcreteIterator）**

```java
public class BookIterator implements Iterator {
    private Book[] books;   // 书的集合
    private int position;   // 当前遍历的位置

    public BookIterator(Book[] books) {
        this.books = books;
        this.position = 0;  // 初始位置为0
    }

    @Override
    public boolean hasNext() {
        return position < books.length && books[position] != null;
    }

    @Override
    public Object next() {
        Book book = books[position];
        position++;
        return book;
    }
}
```

#### 3. **集合接口（Aggregate）**

```java
public interface Aggregate {
    Iterator createIterator();
}
```

#### 4. **具体集合（ConcreteAggregate）**

```java
public class BookShelf implements Aggregate {
    private Book[] books;  // 书的集合
    private int count = 0; // 记录书的数量

    public BookShelf(int maxSize) {
        this.books = new Book[maxSize];
    }

    public void addBook(Book book) {
        if (count < books.length) {
            books[count] = book;
            count++;
        }
    }

    @Override
    public Iterator createIterator() {
        return new BookIterator(books);
    }
}
```

#### 5. **书的类（Book）**

```java
public class Book {
    private String title;

    public Book(String title) {
        this.title = title;
    }

    public String getTitle() {
        return title;
    }
}
```

#### 6. **客户端代码（Client）**

```java
public class Client {
    public static void main(String[] args) {
        // 创建一个书架，最大存储5本书
        BookShelf bookShelf = new BookShelf(5);

        // 添加书籍
        bookShelf.addBook(new Book("设计模式"));
        bookShelf.addBook(new Book("重构"));
        bookShelf.addBook(new Book("算法导论"));
        bookShelf.addBook(new Book("代码整洁之道"));

        // 创建书架的迭代器
        Iterator iterator = bookShelf.createIterator();

        // 使用迭代器遍历所有的书
        while (iterator.hasNext()) {
            Book book = (Book) iterator.next();
            System.out.println("正在浏览的书籍：" + book.getTitle());
        }
    }
}
```

#### 运行结果

```tex
正在浏览的书籍：设计模式
正在浏览的书籍：重构
正在浏览的书籍：算法导论
正在浏览的书籍：代码整洁之道
```

### 优缺点分析

**优点：**

1. **统一的遍历接口**：客户端通过`hasNext()`和`next()`来遍历集合中的元素。
2. **隐藏集合的内部结构**：客户端不需要了解集合的内部实现。
3. **解耦遍历和集合**：遍历和集合分开实现，便于修改和扩展。

**缺点：**

1. **开销大**：对于大规模集合，迭代器会增加遍历的开销。
2. **过度抽象**：在简单的集合（如数组）中，直接使用for循环可能更高效。

### 最佳实践

1. **使用内置迭代器**：像Java的`List`、`Set`和`Map`都内置了迭代器，避免手工实现。
2. **避免过度使用**：对于小型集合，直接用for循环可能更简单。
3. **配合组合模式**：在树形结构中，使用**组合模式和迭代器模式结合**，可遍历树中的所有节点。

### 总结

**迭代器模式**通过提供一个**统一的遍历接口**，将遍历逻辑与集合的实现分离。
这使得客户端**不需要了解集合的内部实现细节**，便能**遍历集合中的元素**。
迭代器在**数据结构库（如Java的List）**中被广泛使用。

------

## 中介者模式

### 中介者模式：用一个中介对象来管理对象之间的交互

#### 现实场景：**机场的航空管制中心**

在机场，多个飞机在跑道上**起飞和降落**。
如果每架飞机都需要**直接与其他飞机通信**，会导致**混乱且不安全**的局面。

为了解决这个问题，机场引入了一个**航空管制中心（ATC，Air Traffic Control）**，
**每架飞机不直接与其他飞机通信，而是与航空管制中心通信**，
管制中心会**协调各架飞机的起飞、降落、等待等指令**，确保飞行的安全和有序。

### 什么是中介者模式？

**中介者模式（Mediator Pattern）\**是一种\**行为型设计模式**，它定义了一个中介对象，
**通过中介对象来封装对象之间的交互**，从而使对象之间的交互变得简单和可维护。

**核心思想：**

1. **通过中介者来协调对象之间的交互**，每个对象只需要和中介者打交道，而不需要直接与其他对象通信。
2. **减少对象之间的直接耦合**，避免了“**网状依赖关系**”，将系统的交互变成“**星形结构**”。

### 中介者模式的核心角色

1. **中介者接口（Mediator）**：
   - 声明了对象之间的通信方法，如`sendMessage()`。
2. **具体中介者（ConcreteMediator）**：
   - 实现中介者接口，负责管理和协调对象之间的通信。
3. **同事接口（Colleague）**：
   - 定义同事对象的接口，确保所有同事都能与中介者进行通信。
4. **具体同事（ConcreteColleague）**：
   - 具体的同事类，负责与中介者通信，将消息传递给中介者，而不是直接与其他同事通信。

### 为什么使用中介者模式？

1. **解耦对象之间的关系**：对象之间不再直接通信，**而是通过中介者通信**，从而减少了类之间的依赖关系。
2. **简化系统的复杂性**：通过中介者，系统从“**网状依赖**”变成“**星形依赖**”，提高了代码的可维护性。
3. **集中管理对象交互**：交互逻辑集中在中介者中，便于调整和修改，而不需要修改具体的对象类。

### 中介者模式的实现方法

1. **定义中介者接口**，提供消息发送方法`sendMessage()`。
2. **实现具体的中介者类**，负责管理和协调对象之间的交互。
3. **定义同事接口**，让同事类实现`receiveMessage()`等方法。
4. **实现具体的同事类**，将消息的发送和接收通过中介者完成。

### 示例：**聊天室系统的实现**

假设有一个**聊天室**，用户可以通过中介者（服务器）发送消息，
中介者会将消息广播给**所有的用户**。

#### 1. **中介者接口（Mediator）**

```java
public interface Mediator {
    void sendMessage(String message, Colleague sender); // 发送消息
    void addUser(Colleague user); // 添加用户到聊天室
}
```

#### 2. **具体中介者（ConcreteMediator）**

```java
import java.util.ArrayList;
import java.util.List;

public class ChatRoomMediator implements Mediator {
    private List<Colleague> users; // 记录聊天室中的所有用户

    public ChatRoomMediator() {
        this.users = new ArrayList<>();
    }

    @Override
    public void addUser(Colleague user) {
        users.add(user);
    }

    @Override
    public void sendMessage(String message, Colleague sender) {
        for (Colleague user : users) {
            // 不要向自己发送消息
            if (user != sender) {
                user.receiveMessage(message);
            }
        }
    }
}
```

#### 3. **同事接口（Colleague）**

```java
public interface Colleague {
    void sendMessage(String message); // 发送消息
    void receiveMessage(String message); // 接收消息
}
```

#### 4. **具体同事（ConcreteColleague）**

```java
public class User implements Colleague {
    private String name;
    private Mediator mediator; // 用户与中介者关联

    public User(String name, Mediator mediator) {
        this.name = name;
        this.mediator = mediator;
    }

    @Override
    public void sendMessage(String message) {
        System.out.println(name + " 发送消息: " + message);
        mediator.sendMessage(message, this); // 通过中介者发送消息
    }

    @Override
    public void receiveMessage(String message) {
        System.out.println(name + " 收到消息: " + message);
    }
}
```

#### 5. **客户端（Client）**

```java
public class Client {
    public static void main(String[] args) {
        // 创建聊天室（中介者）
        ChatRoomMediator chatRoom = new ChatRoomMediator();

        // 创建用户并加入聊天室
        User user1 = new User("Alice", chatRoom);
        User user2 = new User("Bob", chatRoom);
        User user3 = new User("Charlie", chatRoom);

        chatRoom.addUser(user1);
        chatRoom.addUser(user2);
        chatRoom.addUser(user3);

        // 用户发送消息
        user1.sendMessage("大家好，我是Alice！");
        user2.sendMessage("欢迎Alice！");
    }
}
```

#### **运行结果**

```tex
Alice 发送消息: 大家好，我是Alice！
Bob 收到消息: 大家好，我是Alice！
Charlie 收到消息: 大家好，我是Alice！

Bob 发送消息: 欢迎Alice！
Alice 收到消息: 欢迎Alice！
Charlie 收到消息: 欢迎Alice！
```

### 优缺点分析

**优点：**

1. **减少对象之间的依赖**：同事对象不直接通信，而是通过中介者通信。
2. **提高代码的可维护性**：中介者控制交互逻辑，便于修改和扩展。
3. **减少“网状结构”**：将网状关系变成“星形结构”，使系统更加清晰。

**缺点：**

1. **中介者变得复杂**：中介者类可能会变得**非常复杂**，因为它包含了所有对象的交互逻辑。
2. **中介者的单点故障**：如果中介者出现问题，整个系统的通信可能中断。

### 最佳实践

1. **适用于复杂的对象交互**：如**聊天系统**、**航空调度系统**。
2. **避免中介者的臃肿**：将中介者的逻辑拆分成多个小的中介者。
3. **可结合观察者模式**：中介者和观察者模式经常结合使用，用于**事件通知系统**。

### 总结

**中介者模式**通过一个**中介者对象**，协调多个对象之间的交互，
从而避免了对象之间的**直接通信和网状依赖**，使系统更加易于扩展和维护。
在**聊天系统**、**航班调度**和**MVC控制器**中，**中介者的角色不可或缺**。

------

## 备忘录模式

### 备忘录模式：保存对象的状态以便恢复

#### 现实场景：**文本编辑器的撤销功能**

假设你正在使用一个文本编辑器，编辑过程中你可能不小心删除了一些内容或做了一些错误的修改。你希望能够**撤销这些操作**，恢复到某个之前的状态。为了实现这一点，文本编辑器需要**记录每次修改的状态**，并能在用户请求时**恢复到某个特定的状态**。这种保存和恢复对象状态的机制就是**备忘录模式**的应用。

------

### 什么是备忘录模式？

**备忘录模式（Memento Pattern）** 是一种**行为型设计模式**，它允许在不暴露对象内部细节的情况下，**保存和恢复对象的状态**。
这个模式主要用于实现**撤销操作**，也就是在某些情况下需要**回溯到之前的状态**。

### 备忘录模式的核心角色

1. **发起人（Originator）**：
   - 发起人是需要保存和恢复状态的对象，通常它会在其内部包含多个状态。
   - 它有能力生成一个备忘录对象，并通过备忘录恢复状态。
2. **备忘录（Memento）**：
   - 备忘录对象保存了发起人的内部状态。
   - 备忘录通常是不可修改的，以保证状态的完整性。
3. **管理者（Caretaker）**：
   - 管理者负责维护备忘录的生命周期，保存备忘录并在需要时请求恢复操作。
   - 管理者不需要知道备忘录的具体实现细节，只需要存储它。

### 为什么使用备忘录模式？

1. **实现撤销和恢复功能**：允许系统在不暴露内部实现的前提下，保存和恢复对象的状态。
2. **不破坏封装**：发起人的内部状态是封装的，其他对象无法直接访问或修改它们，只能通过备忘录来获取和恢复。
3. **支持历史记录功能**：适用于需要维护历史记录的场景，如文档编辑、游戏状态恢复等。

### 备忘录模式的实现方法

1. **创建发起人类**，包含要保存的状态，并提供方法生成备忘录。
2. **创建备忘录类**，保存发起人的状态。
3. **创建管理者类**，负责保存备忘录对象，并根据需要进行恢复。

### 示例：文本编辑器的撤销功能

假设我们设计一个简单的文本编辑器，可以记录和恢复文本的内容。每次修改后，编辑器都将保存当前文本的状态，并在用户请求时恢复。

#### 1. **发起人类（Originator）**

```java
public class TextEditor {
    private String content; // 文本内容

    public void setContent(String content) {
        this.content = content;
    }

    public String getContent() {
        return content;
    }

    // 创建备忘录
    public Memento createMemento() {
        return new Memento(content);
    }

    // 恢复到备忘录中的状态
    public void restoreMemento(Memento memento) {
        this.content = memento.getContent();
    }
}
```

#### 2. **备忘录类（Memento）**

```java
public class Memento {
    private String content; // 保存的文本内容

    public Memento(String content) {
        this.content = content;
    }

    public String getContent() {
        return content;
    }
}
```

#### 3. **管理者类（Caretaker）**

```java
import java.util.Stack;

public class History {
    private Stack<Memento> mementoStack = new Stack<>();

    // 保存备忘录
    public void saveMemento(Memento memento) {
        mementoStack.push(memento);
    }

    // 获取并移除最新的备忘录
    public Memento getLastMemento() {
        if (!mementoStack.isEmpty()) {
            return mementoStack.pop();
        }
        return null;
    }
}
```

#### 4. **客户端代码（Client）**

```java
public class Client {
    public static void main(String[] args) {
        // 创建文本编辑器
        TextEditor editor = new TextEditor();
        // 创建管理者
        History history = new History();

        // 修改内容并保存
        editor.setContent("Hello, world!");
        history.saveMemento(editor.createMemento()); // 保存状态

        // 修改内容并保存
        editor.setContent("Hello, Design Patterns!");
        history.saveMemento(editor.createMemento()); // 保存状态

        // 用户撤销操作
        editor.restoreMemento(history.getLastMemento()); // 恢复到上一步
        System.out.println("撤销后内容: " + editor.getContent());

        // 用户再次撤销操作
        editor.restoreMemento(history.getLastMemento()); // 恢复到最初
        System.out.println("再次撤销后内容: " + editor.getContent());
    }
}
```

#### **运行结果**

```tex
makefile撤销后内容: Hello, world!
再次撤销后内容: Hello, Design Patterns!
```

### 优缺点分析

**优点：**

1. **实现撤销/恢复功能**：可以轻松地保存和恢复对象的状态，支持历史操作功能。
2. **不暴露内部实现细节**：对象的内部状态是封装的，外部无法直接访问，只能通过备忘录来操作。
3. **简化对象的管理**：通过备忘录将对象的状态管理独立出来，避免了复杂的状态恢复逻辑。

**缺点：**

1. **消耗内存**：每次操作都需要保存状态，如果状态变得很大或频繁操作，会增加系统的内存消耗。
2. **管理复杂性**：在多次操作的情况下，备忘录的管理可能变得复杂，尤其是备忘录的数量很大时。

### 最佳实践

1. **避免频繁创建备忘录**：只有在需要撤销/恢复的情况下才保存状态，避免不必要的内存开销。
2. **结合其他模式**：备忘录模式可以与命令模式结合使用，来实现复杂的撤销/恢复操作。
3. **限量备份**：对于长期运行的系统，可以使用**限量备份**策略，只保存最近的一定数量的备忘录，避免占用过多内存。

### 总结

**备忘录模式**通过提供一个独立的备忘录对象来保存对象的状态，
实现了**对象状态的恢复**，广泛应用于**撤销功能**、**历史记录管理**等场景。
它避免了暴露对象的内部细节，简化了对象状态管理，并有效地支持了**恢复功能**。

------

## 观察者模式

### 观察者模式：定义对象之间的一对多依赖关系

#### 现实场景：**天气预报系统**

假设你正在开发一个天气预报系统，用户可以订阅天气变化的通知。当天气预报更新时，系统应该自动通知所有订阅的用户，而不需要逐个通知。**观察者模式**就是一种非常适合这种“一对多”依赖关系的设计模式。

### 什么是观察者模式？

**观察者模式（Observer Pattern）** 是一种**行为型设计模式**，它定义了对象之间的一对多依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都会自动收到通知并更新。
这个模式的核心在于让被观察者（Subject）和观察者（Observer）解耦，使得被观察者的状态变化可以自动传递给所有观察者，而不需要直接联系。

### 观察者模式的核心角色

1. **主题（Subject）**：
   - 也叫被观察者，负责维护一组观察者，并在状态变化时通知它们。
   - 提供注册、移除和通知观察者的接口。
2. **观察者（Observer）**：
   - 负责接收主题的通知，通常会在主题的状态发生变化时做出反应。
   - 定义更新接口，让主题调用。
3. **具体主题（Concrete Subject）**：
   - 继承自主题，包含具体的状态，并实现状态变更时通知所有观察者的逻辑。
4. **具体观察者（Concrete Observer）**：
   - 继承自观察者，具体实现更新接口，接收并处理主题状态的变化。

### 为什么使用观察者模式？

1. **解耦：**主题和观察者之间没有强耦合关系，主题只需要管理观察者的注册和通知，而不关心观察者如何响应变化。
2. **动态通知：**当主题的状态发生变化时，所有观察者都能被自动通知，无需显式地调用每个观察者。
3. **扩展性：**观察者模式允许动态添加或移除观察者，适应不同的需求和场景。

### 观察者模式的实现方法

1. **定义主题接口：**包括添加、移除和通知观察者的方法。
2. **定义观察者接口：**包括更新的方法。
3. **实现具体主题：**将主题的状态与观察者进行通知。
4. **实现具体观察者：**根据接收到的通知做出响应。

### 示例：天气预报系统

假设我们设计一个天气预报系统，当天气变化时，所有订阅该天气的用户会收到更新通知。我们可以通过观察者模式来实现。

#### 1. **主题接口（Subject）**

```java
public interface Subject {
    void registerObserver(Observer observer);   // 注册观察者
    void removeObserver(Observer observer);     // 移除观察者
    void notifyObservers();                     // 通知所有观察者
}
```

#### 2. **观察者接口（Observer）**

```java
public interface Observer {
    void update(String weather);   // 更新方法，接收天气信息
}
```

#### 3. **具体主题（Concrete Subject）**

```java
import java.util.ArrayList;
import java.util.List;

public class WeatherStation implements Subject {
    private List<Observer> observers;  // 观察者列表
    private String weather;            // 当前天气

    public WeatherStation() {
        observers = new ArrayList<>();
    }

    // 注册观察者
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    // 移除观察者
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    // 通知所有观察者
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(weather);
        }
    }

    // 设置新的天气信息
    public void setWeather(String weather) {
        this.weather = weather;
        notifyObservers();  // 状态变化时通知所有观察者
    }
}
```

#### 4. **具体观察者（Concrete Observer）**

```java
public class WeatherApp implements Observer {
    private String weather;  // 存储最新的天气

    @Override
    public void update(String weather) {
        this.weather = weather;
        display();
    }

    public void display() {
        System.out.println("最新天气： " + weather);
    }
}
```

#### 5. **客户端代码（Client）**

```java
public class Client {
    public static void main(String[] args) {
        // 创建天气站（主题）
        WeatherStation weatherStation = new WeatherStation();

        // 创建多个天气应用（观察者）
        WeatherApp app1 = new WeatherApp();
        WeatherApp app2 = new WeatherApp();

        // 注册观察者
        weatherStation.registerObserver(app1);
        weatherStation.registerObserver(app2);

        // 修改天气，通知所有观察者
        weatherStation.setWeather("晴天");

        // 移除一个观察者
        weatherStation.removeObserver(app2);

        // 修改天气，通知剩下的观察者
        weatherStation.setWeather("雨天");
    }
}
```

#### **运行结果**

```tex
最新天气： 晴天
最新天气： 晴天
最新天气： 雨天
```

### 优缺点分析

**优点：**

1. **解耦**：主题和观察者之间的耦合较低，易于扩展。
2. **动态更新**：一旦主题状态发生变化，所有观察者都能自动得到更新。
3. **易于维护**：增加或删除观察者非常简单，不会影响到其他对象。

**缺点：**

1. **可能有性能问题**：如果观察者很多，通知机制可能带来性能负担，尤其是在主题状态频繁变化时。
2. **依赖关系可能变得复杂**：如果主题的变化过于复杂，观察者的处理逻辑可能会变得庞大，影响系统的可维护性。

### 最佳实践

1. **避免过多的观察者**：尽量避免过多的观察者，确保通知机制高效。
2. **确保线程安全**：如果系统是多线程的，确保观察者模式的实现是线程安全的。
3. **事件批处理**：考虑使用事件批处理的方式，减少频繁的更新通知。

### 总结

**观察者模式**通过定义一对多的依赖关系，使得当主题状态发生变化时，所有观察者都能够自动得到更新。它解耦了主题和观察者，提升了系统的灵活性和扩展性。在实际开发中，观察者模式广泛应用于**事件驱动的系统**、**推送通知**以及**数据同步**等场景。

------

## 状态模式

### 状态模式：允许对象在内部状态改变时改变其行为

#### 现实场景：**电梯系统**

假设你在开发一个电梯控制系统。电梯有多个状态，比如“停止”、“运行”、“开门”等。在不同的状态下，电梯的行为不同。如果你不使用状态模式，那么每当电梯状态发生变化时，代码会变得非常复杂，且每个状态下的行为都需要通过大量的条件判断来实现。

### 什么是状态模式？

**状态模式（State Pattern）** 是一种**行为型设计模式**，它允许一个对象在其内部状态发生改变时，改变其行为。状态模式的核心思想是：将不同的状态抽象出来，并将每个状态的行为封装到状态对象中。当对象的状态发生改变时，切换到相应的状态对象，从而改变对象的行为。

### 状态模式的核心角色

1. **上下文（Context）：**
   - 维护一个当前状态的引用，并委托状态的切换和行为的执行给具体的状态对象。
2. **状态（State）：**
   - 定义一个接口，用于表示在不同状态下，具体的行为。
3. **具体状态（Concrete State）：**
   - 实现状态接口，定义具体的状态下的行为。

### 为什么使用状态模式？

1. **避免条件语句：**如果一个对象的行为与状态密切相关，通过状态模式可以避免大量的条件判断，代码更清晰易懂。
2. **状态切换灵活：**可以动态地切换对象的状态，允许对象根据不同的状态作出不同的反应。
3. **提高可维护性：**将不同状态的行为分离到不同的状态类中，避免了一个类中堆积过多的状态相关代码。

### 状态模式的实现方法

1. **定义状态接口**：声明一个方法，用于在不同状态下执行特定的操作。
2. **定义具体状态类**：每个具体的状态类都实现状态接口，定义具体的行为。
3. **上下文类**：维护当前状态，并通过切换状态对象来改变行为。

### 示例：电梯系统

假设我们设计一个简单的电梯控制系统，电梯有三个状态：**停止**、**运行**、**开门**。我们将使用状态模式来设计该系统。

#### 1. **状态接口（State）**

```java
public interface ElevatorState {
    void handle();  // 每个状态的行为
}
```

#### 2. **具体状态类（Concrete State）**

```java
// 停止状态
public class StoppedState implements ElevatorState {
    @Override
    public void handle() {
        System.out.println("电梯停止了");
    }
}

// 运行状态
public class RunningState implements ElevatorState {
    @Override
    public void handle() {
        System.out.println("电梯正在运行");
    }
}

// 开门状态
public class DoorOpenState implements ElevatorState {
    @Override
    public void handle() {
        System.out.println("电梯门已打开");
    }
}
```

#### 3. **上下文类（Context）**

```java
public class Elevator {
    private ElevatorState state;  // 当前状态

    public Elevator() {
        this.state = new StoppedState();  // 默认状态为停止状态
    }

    public void setState(ElevatorState state) {
        this.state = state;
    }

    public void pressButton() {
        state.handle();  // 根据当前状态执行不同的行为
    }
}
```

#### 4. **客户端代码（Client）**

```java
public class Client {
    public static void main(String[] args) {
        Elevator elevator = new Elevator();

        // 按下按钮，电梯执行当前状态的行为（初始状态为停止）
        elevator.pressButton();  // 输出：电梯停止了

        // 切换到运行状态
        elevator.setState(new RunningState());
        elevator.pressButton();  // 输出：电梯正在运行

        // 切换到开门状态
        elevator.setState(new DoorOpenState());
        elevator.pressButton();  // 输出：电梯门已打开
    }
}
```

#### **运行结果**

```tex
电梯停止了
电梯正在运行
电梯门已打开
```

### 优缺点分析

**优点：**

1. **清晰易懂**：避免了大量的条件判断，代码更易读、理解和维护。
2. **灵活性高**：允许动态地切换状态，每个状态都有自己独立的行为。
3. **扩展方便**：新增状态时，只需添加新的状态类，无需修改现有代码，符合开闭原则。

**缺点：**

1. **增加类的数量**：每个状态都需要一个独立的类，类的数量可能会增加，导致系统变得庞大。
2. **状态切换过于复杂**：如果状态之间的切换复杂，可能会导致上下文类变得过于复杂。

### 最佳实践

1. **避免过度使用状态模式**：当对象的状态不多或状态之间的行为差异不大时，可能不需要使用状态模式，简单的条件判断即可。
2. **确保状态类职责单一**：每个状态类应仅负责自己状态下的行为，避免将过多的逻辑放入其中。
3. **结合其他模式使用**：在复杂场景中，状态模式可以与策略模式、命令模式等结合使用，提升系统的灵活性。

### 总结

**状态模式**通过将对象的行为与其状态绑定，使得对象能够在状态发生变化时改变其行为。它通过引入状态类来避免复杂的条件判断，提高了代码的可维护性和可扩展性。在实际开发中，状态模式非常适用于具有多个可能状态且行为依赖于状态的系统，如电梯、投币系统等。

------

## 策略模式

### 策略模式：定义一系列算法，并将每个算法封装起来，使它们可以互换

#### 现实场景：**在线支付方式选择**

假设你在开发一个在线购物平台，用户可以选择不同的支付方式，如支付宝、微信支付、信用卡等。在没有使用策略模式的情况下，你可能需要通过大量的条件判断来决定使用哪种支付方式，这样代码不仅繁琐，而且难以扩展。如果要增加新的支付方式，你还需要修改已有的代码。

### 什么是策略模式？

**策略模式（Strategy Pattern）** 是一种**行为型设计模式**，它定义了一系列的算法，并将每一个算法封装起来，使它们可以互相替换。策略模式让算法的变化独立于使用算法的客户，从而实现了算法的解耦。核心思想是：在不同的场景下，可以根据需要选择不同的策略（算法）。

### 策略模式的核心角色

1. **上下文（Context）：**
   - 维护一个对策略对象的引用，通过该引用来调用策略方法。
2. **策略接口（Strategy）：**
   - 定义一个通用的算法接口，所有具体的策略类都必须实现此接口。
3. **具体策略（Concrete Strategy）：**
   - 每个具体的策略类实现了策略接口，封装了具体的算法或行为。

------

### 为什么使用策略模式？

1. **避免条件语句：**如果一个对象的行为依赖于多个算法，通过策略模式可以避免大量的条件语句。
2. **提升可扩展性：**增加新的策略时，不需要修改现有代码，只需新增具体的策略类，符合开闭原则。
3. **策略独立：**各个策略类封装了不同的算法，彼此独立，便于维护和修改。

### 策略模式的实现方法

1. **定义策略接口**：声明一个算法的通用接口。
2. **定义具体策略类**：每个策略类实现策略接口，定义具体的算法。
3. **上下文类**：保存一个对策略对象的引用，并调用策略方法。

### 示例：在线支付方式选择

假设我们在开发一个电子商务平台，用户可以选择不同的支付方式：支付宝、微信支付、信用卡等。我们将使用策略模式来设计支付方式选择系统。

#### 1. **策略接口（Strategy）**

```java
// 支付策略接口
public interface PaymentStrategy {
    void pay(double amount);  // 支付方法
}
```

#### 2. **具体策略类（Concrete Strategy）**

```java
// 支付宝支付
public class AlipayPayment implements PaymentStrategy {
    @Override
    public void pay(double amount) {
        System.out.println("使用支付宝支付：" + amount + "元");
    }
}

// 微信支付
public class WeChatPayment implements PaymentStrategy {
    @Override
    public void pay(double amount) {
        System.out.println("使用微信支付：" + amount + "元");
    }
}

// 信用卡支付
public class CreditCardPayment implements PaymentStrategy {
    @Override
    public void pay(double amount) {
        System.out.println("使用信用卡支付：" + amount + "元");
    }
}
```

#### 3. **上下文类（Context）**

```java
// 支付上下文类
public class PaymentContext {
    private PaymentStrategy paymentStrategy;  // 当前支付策略

    public PaymentContext(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    // 设置支付方式
    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    // 执行支付
    public void executePayment(double amount) {
        paymentStrategy.pay(amount);
    }
}
```

#### 4. **客户端代码（Client）**

```java
public class Client {
    public static void main(String[] args) {
        // 创建支付上下文，并选择支付方式为支付宝支付
        PaymentContext context = new PaymentContext(new AlipayPayment());
        context.executePayment(100.0);  // 输出：使用支付宝支付：100.0元

        // 切换支付方式为微信支付
        context.setPaymentStrategy(new WeChatPayment());
        context.executePayment(50.0);  // 输出：使用微信支付：50.0元

        // 切换支付方式为信用卡支付
        context.setPaymentStrategy(new CreditCardPayment());
        context.executePayment(200.0);  // 输出：使用信用卡支付：200.0元
    }
}
```

#### **运行结果**

```tex
使用支付宝支付：100.0元
使用微信支付：50.0元
使用信用卡支付：200.0元
```

### 优缺点分析

**优点：**

1. **避免条件语句**：通过策略模式，避免了在上下文类中加入复杂的条件判断，简化了代码。
2. **扩展性好**：添加新的支付方式时，只需要新增一个支付策略类，而无需修改现有代码，符合开闭原则。
3. **灵活性高**：可以在运行时动态切换支付策略，改变支付方式。

**缺点：**

1. **增加类的数量**：每个支付方式都需要一个独立的策略类，类的数量可能会增加，系统可能变得复杂。
2. **客户端需要知道策略**：客户端代码需要知道具体的策略类，这可能会引入一定的耦合。

### 最佳实践

1. **尽量使用策略模式解决多算法的选择问题**：当某个对象需要根据不同的条件选择不同的行为时，策略模式是一个理想的选择。
2. **将策略类设计得简洁明了**：每个策略类应该只负责实现一个独立的算法，避免将多个算法混合到一个策略类中。
3. **策略切换动态**：可以根据不同的需求或环境动态切换策略，使得系统具有较高的灵活性。

### 总结

**策略模式**通过将算法封装到独立的策略类中，使得这些算法可以互相替换，避免了大量的条件判断。它提高了代码的灵活性和可维护性，特别适用于具有多种算法或行为的场景，如支付方式选择、排序策略等。在实际开发中，当对象的行为依赖于多个不同的算法时，可以考虑使用策略模式。

------

## 外观模式

### 外观模式：为子系统提供统一接口

#### 现实场景：智能家居的控制中心

假设你家里有各种智能设备，比如智能灯、智能电视和智能空调。每个设备都有自己的控制方式。如果每次都需要分别操作这些设备会非常麻烦。那么，假如有一个智能家居控制中心，可以一键开启或关闭所有设备，操作就会变得简单方便。这就是**简化复杂系统接口**的方式，也是**外观模式**的典型应用。

### 什么是外观模式？

**外观模式（Facade Pattern）** 是一种**结构型设计模式**，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。外观模式的核心思想是通过一个外观类，将复杂的子系统接口封装起来，客户端只需通过外观类与子系统交互，而不需要了解子系统的内部实现。

### 外观模式的核心角色

1. **外观类（Facade）**：
   - 提供一个高层接口，供客户端访问子系统的功能。
   - 它封装了子系统的复杂性，简化了客户端与子系统的交互。
2. **子系统（Subsystem）**：
   - 包含具体的业务逻辑和实现细节。
   - 子系统的组件独立工作，不直接与外观类通信。
3. **客户端（Client）**：
   - 通过外观类与子系统交互。

### 为什么使用外观模式？

1. **简化复杂系统**：通过外观类，隐藏子系统的复杂性，提供一个简洁的接口，方便客户端使用。
2. **解耦客户端和子系统**：外观类充当了客户端与子系统之间的中介，从而降低了它们之间的耦合度。
3. **提升代码可维护性**：子系统的实现细节对客户端隐藏，外观类提供的统一接口使得系统更易维护。

### 外观模式的实现方法

1. **定义子系统类**：实现具体的功能逻辑。
2. **定义外观类**：封装对子系统类的调用，提供统一接口。
3. **客户端代码**：通过外观类与子系统交互。

### 示例：智能家居控制中心

假设我们有三个智能设备：灯光、电视和空调。通过外观模式，我们设计一个智能家居控制中心，可以统一管理这些设备。

#### 1. **子系统类（Subsystem）**

```java
// 智能灯光
public class Light {
    public void turnOn() {
        System.out.println("灯光已打开");
    }

    public void turnOff() {
        System.out.println("灯光已关闭");
    }
}

// 智能电视
public class TV {
    public void turnOn() {
        System.out.println("电视已打开");
    }

    public void turnOff() {
        System.out.println("电视已关闭");
    }
}

// 智能空调
public class AirConditioner {
    public void turnOn() {
        System.out.println("空调已打开");
    }

    public void turnOff() {
        System.out.println("空调已关闭");
    }
}
```

#### 2. **外观类（Facade）**

```java
// 外观类：智能家居控制中心
public class SmartHomeFacade {
    private Light light;
    private TV tv;
    private AirConditioner airConditioner;

    public SmartHomeFacade() {
        this.light = new Light();
        this.tv = new TV();
        this.airConditioner = new AirConditioner();
    }

    // 一键开启所有设备
    public void turnOnAll() {
        System.out.println("一键开启所有设备：");
        light.turnOn();
        tv.turnOn();
        airConditioner.turnOn();
    }

    // 一键关闭所有设备
    public void turnOffAll() {
        System.out.println("一键关闭所有设备：");
        light.turnOff();
        tv.turnOff();
        airConditioner.turnOff();
    }
}
```

#### 3. **客户端代码（Client）**

```java
public class Client {
    public static void main(String[] args) {
        // 创建智能家居控制中心
        SmartHomeFacade smartHome = new SmartHomeFacade();

        // 一键开启所有设备
        smartHome.turnOnAll();

        // 一键关闭所有设备
        smartHome.turnOffAll();
    }
}
```

#### 运行结果

```tex
一键开启所有设备：
灯光已打开
电视已打开
空调已打开
一键关闭所有设备：
灯光已关闭
电视已关闭
空调已关闭
```

### 优缺点分析

**优点：**

1. **简化接口**：外观模式通过外观类为复杂的子系统提供了一个简单的接口，方便客户端使用。
2. **降低耦合**：客户端只需要与外观类交互，而无需直接依赖子系统，从而降低了系统的耦合度。
3. **提高可维护性**：子系统的实现细节对客户端隐藏，客户端的改动不会影响子系统。

**缺点：**

1. **增加外观类的复杂性**：随着子系统功能的增加，外观类可能会变得臃肿，难以维护。
2. **限制子系统的灵活性**：客户端通过外观类与子系统交互，可能无法直接访问子系统的某些高级功能。

### 最佳实践

1. **避免过度设计**：只有当系统的子系统较为复杂，且客户端需要频繁交互时才使用外观模式。
2. **与其他模式结合使用**：外观模式可以与单例模式结合，确保外观类只有一个实例；也可以与策略模式结合，为不同客户端提供定制化的外观。
3. **保持外观类简洁**：外观类应该只负责简化接口，不应该承担太多的业务逻辑。

### 总结

外观模式通过引入一个外观类，为复杂的子系统提供了一个统一的接口，简化了客户端与子系统的交互。它不仅降低了系统的复杂性，还提升了代码的可维护性。在实际开发中，当系统变得复杂且子系统较多时，可以考虑使用外观模式来简化接口和降低耦合。

------

## 访问者模式

### 访问者模式：让你可以在不改变元素结构的前提下，新增对元素的操作

#### 现实场景：公司人员评估

假设你在一个公司工作，作为人力资源经理，你每年都需要对公司的不同部门员工进行评估。每个部门的工作性质不同，评估标准也不相同。如果每次评估都需要写不同的逻辑来处理各部门的员工，你会发现代码会变得非常繁琐。为了简化这些操作，你可以使用**访问者模式**。通过将评估的逻辑分离出来，而不是直接在员工对象中实现，可以使得评估逻辑更加清晰且容易扩展。

### 什么是访问者模式？

**访问者模式（Visitor Pattern）** 是一种**行为型设计模式**，它使得你可以在不改变对象结构的情况下，定义作用于这些对象的新操作。通过使用访问者模式，你可以将新的操作添加到类中，而不需要修改原有的类。

访问者模式的核心思想是将操作封装在一个访问者类中，而让元素类保持不变。元素类通过接收访问者来执行相应的操作，这样就避免了在元素类中加入大量的操作方法。

### 访问者模式的核心角色

1. **访问者（Visitor）**：
   - 定义对每个元素类的操作。访问者类包含不同的操作方法，它为每种类型的元素提供具体的访问操作。
2. **元素（Element）**：
   - 定义一个接受访问者的接口。每个元素实现这个接口，并通过这个接口接受访问者的访问。
3. **具体元素（ConcreteElement）**：
   - 实现元素接口，并定义接受访问者的方法。
4. **对象结构（ObjectStructure）**：
   - 维护元素对象的集合，并可以遍历这些元素，接受访问者的访问。

### 为什么使用访问者模式？

1. **增加操作的灵活性**：当你需要对对象进行不同的操作，且这些操作和对象结构无关时，可以通过访问者模式将这些操作与元素类分离，增加操作的灵活性。
2. **扩展性强**：当需要为元素类添加新的操作时，只需要新增一个访问者，而不需要修改元素类本身。
3. **减少代码重复**：通过访问者模式，可以将不同的操作集中到一个地方，减少在不同类中重复编写类似的操作。

### 访问者模式的实现方法

1. **定义元素接口（Element）**：该接口包含接受访问者的方法。
2. **定义具体元素（ConcreteElement）**：实现元素接口并实现具体的操作。
3. **定义访问者接口（Visitor）**：定义对各元素类的操作。
4. **定义具体访问者（ConcreteVisitor）**：实现访问者接口并为每种元素提供具体操作。
5. **对象结构**：维护元素对象的集合，接受访问者的访问。

### 示例：公司员工评估

假设公司有不同类型的员工，比如工程师和经理。每年HR需要根据不同的职位进行不同的评估。

#### 1. 元素接口（Element）

```java
// 员工接口
public interface Employee {
    void accept(Visitor visitor);  // 接受访问者
}
```

#### 2. **具体元素（ConcreteElement）**

```java
// 工程师类
public class Engineer implements Employee {
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);  // 向访问者传递自身对象
    }

    public void performTask() {
        System.out.println("工程师在执行编程任务");
    }
}

// 经理类
public class Manager implements Employee {
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);  // 向访问者传递自身对象
    }

    public void manageTeam() {
        System.out.println("经理在管理团队");
    }
}
```

#### 3. **访问者接口（Visitor）**

```java
// 访问者接口
public interface Visitor {
    void visit(Engineer engineer);  // 访问工程师
    void visit(Manager manager);    // 访问经理
}
```

#### 4. **具体访问者（ConcreteVisitor）**

```java
// 评估访问者
public class EvaluationVisitor implements Visitor {
    @Override
    public void visit(Engineer engineer) {
        System.out.println("评估工程师的工作表现");
        engineer.performTask();
    }

    @Override
    public void visit(Manager manager) {
        System.out.println("评估经理的管理能力");
        manager.manageTeam();
    }
}
```

#### 5. **对象结构（ObjectStructure）**

```java
import java.util.ArrayList;
import java.util.List;

// 员工结构：公司员工集合
public class Company {
    private List<Employee> employees;

    public Company() {
        employees = new ArrayList<>();
        employees.add(new Engineer());
        employees.add(new Manager());
    }

    public void accept(Visitor visitor) {
        for (Employee employee : employees) {
            employee.accept(visitor);  // 每个员工都接受访问者的访问
        }
    }
}
```

#### 6. **客户端代码（Client）**

```java
public class Client {
    public static void main(String[] args) {
        Company company = new Company();  // 创建公司对象
        Visitor evaluationVisitor = new EvaluationVisitor();  // 创建评估访问者

        // 让公司员工接受评估
        company.accept(evaluationVisitor);
    }
}
```

#### 运行结果

```tex
评估工程师的工作表现
工程师在执行编程任务
评估经理的管理能力
经理在管理团队
```

### 优缺点分析

**优点：**

1. **操作与类结构分离**：访问者模式将操作从元素类中分离出来，使得操作逻辑更加集中，易于管理和扩展。
2. **增加新操作容易**：每次需要增加新操作时，只需要增加一个新的访问者，不需要修改元素类。
3. **元素类保持简洁**：元素类只关注自己的行为，不需要关注具体操作的实现。

**缺点：**

1. **增加访问者的复杂性**：每增加一个访问者，就需要在所有的元素类中增加新的访问方法，导致系统变得复杂。
2. **违反单一职责原则**：访问者模式将多个操作集中在一个类中，可能导致单一职责原则的违反。
3. **元素类变化时需要修改访问者**：如果元素类发生变化，需要修改所有的访问者，这可能增加维护成本。

### 最佳实践

1. **适用于元素结构不常变化**：访问者模式适用于元素类的结构不频繁变化的情况，因为一旦元素类发生变化，需要修改访问者类。
2. **避免过度使用**：如果操作较少且元素类简单，使用访问者模式可能会显得过于复杂，简单的解决方案可能更好。
3. **结合其他设计模式**：访问者模式可以和其他设计模式结合使用，比如工厂模式，用于创建访问者实例。

### 总结

访问者模式通过将操作分离到访问者类中，使得你可以在不修改元素类的情况下，增加新的操作。这种模式特别适用于需要对对象进行多种操作的场景，如不同的业务逻辑需要作用于相同的元素对象。访问者模式提高了代码的扩展性，但也可能导致访问者类之间的耦合度较高，因此需要谨慎使用。